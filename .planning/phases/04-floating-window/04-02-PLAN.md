---
phase: 04-floating-window
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - ClaudeMon/Views/FloatingWindow/FloatingWindowView.swift
  - ClaudeMon/Services/FloatingWindowController.swift
  - ClaudeMon/ClaudeMonApp.swift
autonomous: false

must_haves:
  truths:
    - "User can open floating window from right-click context menu"
    - "Floating window shows live usage percentage that updates when UsageMonitor refreshes"
    - "Floating window shows status text (limit status) based on alert level"
    - "Floating window uses gradient colors matching the menu bar"
    - "User can close the floating window without quitting the app"
    - "User can drag floating window to any position and it remembers position on restart"
  artifacts:
    - path: "ClaudeMon/Views/FloatingWindow/FloatingWindowView.swift"
      provides: "Compact usage display SwiftUI view"
      contains: "struct FloatingWindowView"
  key_links:
    - from: "ClaudeMon/Views/FloatingWindow/FloatingWindowView.swift"
      to: "ClaudeMon/Services/UsageMonitor.swift"
      via: "@Environment(UsageMonitor.self)"
      pattern: "@Environment.*UsageMonitor"
    - from: "ClaudeMon/Views/FloatingWindow/FloatingWindowView.swift"
      to: "ClaudeMon/Utilities/GradientColors.swift"
      via: "Color conversion from NSColor"
      pattern: "GradientColors\\.color"
    - from: "ClaudeMon/ClaudeMonApp.swift"
      to: "ClaudeMon/Services/FloatingWindowController.swift"
      via: "Context menu action"
      pattern: "FloatingWindowController\\.shared"
---

<objective>
Build the FloatingWindowView UI displaying live usage data, wire it into the FloatingWindowController, and integrate the "Open Floating Window" action into the menu bar context menu.

Purpose: This completes Phase 4 by delivering the user-facing floating window with live data from UsageMonitor, accessible from the menu bar context menu.

Output: FloatingWindowView showing percentage and status, context menu integration, verified complete floating window experience.
</objective>

<execution_context>
@/Users/richardparr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardparr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-floating-window/04-RESEARCH.md
@.planning/phases/04-floating-window/04-01-SUMMARY.md

# Existing patterns to follow
@ClaudeMon/ClaudeMonApp.swift
@ClaudeMon/Services/UsageMonitor.swift
@ClaudeMon/Utilities/GradientColors.swift
@ClaudeMon/Models/UsageSnapshot.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FloatingWindowView with live usage display</name>
  <files>ClaudeMon/Views/FloatingWindow/FloatingWindowView.swift</files>
  <action>
Create a compact SwiftUI view for the floating window:

```swift
import SwiftUI
import AppKit

/// Compact usage display for the floating window.
/// Shows usage percentage prominently with status indicator.
/// Updates live via @Environment(UsageMonitor.self).
struct FloatingWindowView: View {
    @Environment(UsageMonitor.self) private var monitor
    @Environment(AlertManager.self) private var alertManager

    var body: some View {
        VStack(spacing: 4) {
            // Big percentage number
            Text(percentageText)
                .font(.system(size: 32, weight: .bold, design: .rounded))
                .foregroundStyle(usageColor)
                .monospacedDigit()

            // Status indicator
            Text(statusText)
                .font(.caption)
                .foregroundStyle(.secondary)
        }
        .padding(12)
        .frame(minWidth: 100, minHeight: 60)
    }

    // MARK: - Computed Properties

    private var percentageText: String {
        let usage = monitor.currentUsage
        if usage.source == .none {
            return "--%"
        }
        if usage.hasPercentage {
            return "\(Int(usage.primaryPercentage))%"
        }
        // JSONL fallback: show token count
        return usage.formattedTokenCount
    }

    private var usageColor: Color {
        let usage = monitor.currentUsage
        guard usage.hasPercentage else {
            return Color(nsColor: .secondaryLabelColor)
        }
        let pct = usage.primaryPercentage
        return Color(nsColor: GradientColors.color(for: pct))
    }

    private var statusText: String {
        let usage = monitor.currentUsage
        let level = alertManager.currentAlertLevel

        // Priority: error states
        if case .bothSourcesFailed = monitor.error {
            return "Data unavailable"
        }

        // Priority: JSONL mode (no percentage)
        if !usage.hasPercentage && usage.source == .jsonl {
            return "Local session"
        }

        // Priority: no data
        if usage.source == .none {
            return "Loading..."
        }

        // Alert-level status
        switch level {
        case .critical:
            return "Limit reached"
        case .warning:
            return "Approaching limit"
        case .normal:
            return "5-hour usage"
        }
    }
}
```

Key details:
- Uses @Environment to receive UsageMonitor (injected by FloatingWindowController)
- Uses @Environment to receive AlertManager (for status text based on alert level)
- Percentage text shows "--%" when no data, integer percentage from OAuth, or token count for JSONL
- Status text reflects alert level: "Limit reached", "Approaching limit", "5-hour usage"
- Color uses GradientColors.color(for:) matching the menu bar
- Compact layout: 32pt bold percentage, caption status
- No #Preview macro (SPM compatibility per 03-02/03-03 decisions)
  </action>
  <verify>File compiles: `swift build 2>&1 | head -20`</verify>
  <done>FloatingWindowView.swift exists with compact usage display using UsageMonitor environment</done>
</task>

<task type="auto">
  <name>Task 2: Wire FloatingWindowView to controller and integrate context menu</name>
  <files>
    ClaudeMon/Services/FloatingWindowController.swift
    ClaudeMon/ClaudeMonApp.swift
  </files>
  <action>
**Update FloatingWindowController.swift:**

Replace the placeholder content with the real FloatingWindowView:

1. Import the view file at the top (if needed - same module should auto-resolve)

2. In `showFloatingWindow()`, replace the placeholder Text view:

```swift
// Replace this placeholder:
// let placeholderView = Text("Usage: --%")...

// With the real view:
let contentView = FloatingWindowView()
    .environment(monitor)
    .environment(alertManager)

let hostingController = NSHostingController(rootView: contentView)
newPanel.contentViewController = hostingController
```

**Update ClaudeMonApp.swift:**

1. In the `.menuBarExtraAccess` callback, initialize FloatingWindowController with monitor and alertManager (add after SettingsWindowController setup):

```swift
// Initialize floating window controller with references
FloatingWindowController.shared.setMonitor(monitor)
FloatingWindowController.shared.setAlertManager(alertManager)
```

2. In `StatusItemManager.showContextMenu(monitor:)`, update the floating window menu item:

```swift
// Replace this disabled item:
// let floatingItem = NSMenuItem(title: "Open Floating Window (Phase 4)", action: nil, keyEquivalent: "")
// floatingItem.isEnabled = false

// With this active item:
let floatingItem = NSMenuItem(
    title: FloatingWindowController.shared.isVisible ? "Hide Floating Window" : "Show Floating Window",
    action: #selector(ContextMenuActions.toggleFloatingWindow),
    keyEquivalent: "f"
)
floatingItem.target = actions
```

3. Add the action to `ContextMenuActions`:

```swift
@objc func toggleFloatingWindow() {
    FloatingWindowController.shared.toggleFloatingWindow()
}
```

**Important:** The floating window should not quit the app when closed. This is already handled by:
- ClaudeMon being an LSUIElement app (no dock icon, doesn't terminate on window close)
- `isReleasedWhenClosed = false` in FloatingPanel
  </action>
  <verify>
1. Build succeeds: `swift build 2>&1 | head -20`
2. Run app, right-click menu bar icon, verify "Show Floating Window" appears (not grayed out)
3. Click "Show Floating Window" - floating window should appear
4. Verify floating window shows usage percentage matching menu bar
  </verify>
  <done>FloatingWindowView wired to controller with real usage data, context menu item active and functional</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete Phase 4 floating window experience</name>
  <files>ClaudeMon/ClaudeMonApp.swift</files>
  <action>
CHECKPOINT: Human verification of the complete Phase 4 floating window experience.

What was built: Complete floating window feature with NSPanel configured for always-on-top non-focus-stealing behavior, SwiftUI view showing live usage percentage and status, context menu integration for show/hide, and position persistence between app launches.

How to verify:
1. Open from context menu: Right-click the menu bar icon, click "Show Floating Window". Floating window should appear in top-right corner (or last saved position).
2. Always on top: Click on another app (Terminal, Finder, etc.). Verify the floating window stays visible above other windows. Verify it does NOT activate ClaudeMon (no focus stealing).
3. Live data: Verify the floating window shows the same percentage as the menu bar. Wait for a refresh cycle (or use "Refresh Now"). Verify the floating window updates.
4. Position persistence: Drag the floating window to a different corner. Quit ClaudeMon (Cmd+Q). Relaunch the app. Open floating window again - should appear in the saved position.
5. Close without quit: Click the close button (X) on the floating window. Verify the app does NOT quit (menu bar icon still present). Verify you can reopen from context menu.
6. Toggle behavior: With floating window open, right-click menu bar. Menu should show "Hide Floating Window". Click it - window should close. Right-click again - should show "Show Floating Window".
7. Status text: If usage below threshold: "5-hour usage". Above warning threshold: "Approaching limit". At 100%: "Limit reached".

Resume signal: Type "approved" to complete Phase 4, or describe any issues to fix.
  </action>
  <verify>User confirms all 7 verification steps pass. All Phase 4 success criteria from ROADMAP.md are met.</verify>
  <done>User has approved the complete Phase 4 experience. All 6 requirements (FLOAT-01 through FLOAT-06) verified through human testing.</done>
</task>

</tasks>

<verification>
- Floating window opens from context menu
- Floating window stays on top when clicking other apps
- Floating window does not steal focus
- Floating window shows live usage percentage matching menu bar
- Floating window color gradient matches menu bar
- Floating window position persists across app restarts
- Closing floating window does not quit the app
- Context menu toggle works (Show/Hide)
- Status text reflects current alert level
</verification>

<success_criteria>
- FLOAT-01: User can open a compact floating window from menu bar (context menu item works)
- FLOAT-02: Floating window stays on top of other windows (NSPanel.isFloatingPanel = true)
- FLOAT-03: User can position floating window in any screen corner (draggable)
- FLOAT-04: Floating window remembers position between sessions (setFrameAutosaveName)
- FLOAT-05: Floating window shows minimal usage info (percentage, limit status)
- FLOAT-06: User can close floating window without quitting app (LSUIElement behavior)
- All Phase 4 success criteria from ROADMAP.md verified through human testing
</success_criteria>

<output>
After completion, create `.planning/phases/04-floating-window/04-02-SUMMARY.md`
</output>
