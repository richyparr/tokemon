---
phase: 04-floating-window
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Tokemon/Services/FloatingWindowController.swift
  - Tokemon/Utilities/NSWindow+Position.swift
autonomous: true

must_haves:
  truths:
    - "FloatingPanel stays visible when user clicks on other apps"
    - "FloatingPanel does not steal focus from user's current work"
    - "FloatingWindowController can show and hide the panel"
    - "Panel position is automatically saved and restored between app launches"
  artifacts:
    - path: "Tokemon/Services/FloatingWindowController.swift"
      provides: "Singleton service for floating panel lifecycle management"
      contains: "class FloatingWindowController"
    - path: "Tokemon/Utilities/NSWindow+Position.swift"
      provides: "Window position helper extension"
      contains: "extension NSWindow"
  key_links:
    - from: "FloatingWindowController.swift"
      to: "FloatingPanel (NSPanel subclass)"
      via: "panel property and init configuration"
      pattern: "class FloatingPanel.*NSPanel"
    - from: "FloatingWindowController.swift"
      to: "UserDefaults"
      via: "setFrameAutosaveName"
      pattern: "setFrameAutosaveName"
---

<objective>
Create the foundational AppKit infrastructure for the floating window: NSPanel subclass configured for always-on-top, non-activating behavior, the controller service managing panel lifecycle, and position utilities.

Purpose: The floating window requires specific NSPanel configuration that SwiftUI cannot provide on macOS 14. This plan establishes the AppKit foundation that Plan 04-02 will populate with SwiftUI content.

Output: FloatingPanel class, FloatingWindowController service (following SettingsWindowController pattern), and NSWindow position extension.
</objective>

<execution_context>
@/Users/richardparr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardparr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-floating-window/04-RESEARCH.md

# Existing pattern to follow
@Tokemon/Services/SettingsWindowController.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NSWindow position extension</name>
  <files>Tokemon/Utilities/NSWindow+Position.swift</files>
  <action>
Create a helper extension for positioning windows in screen corners:

```swift
import AppKit

extension NSWindow {
    /// Position specification for window placement
    struct Position {
        enum Horizontal { case left, center, right }
        enum Vertical { case top, center, bottom }

        var vertical: Vertical
        var horizontal: Horizontal
        var padding: CGFloat

        init(vertical: Vertical, horizontal: Horizontal, padding: CGFloat = 16) {
            self.vertical = vertical
            self.horizontal = horizontal
            self.padding = padding
        }
    }

    /// Set the window position relative to the visible screen area.
    /// Respects the menu bar and Dock when calculating position.
    ///
    /// - Parameters:
    ///   - position: Position specification (corner + padding)
    ///   - screen: Target screen (defaults to window's current screen)
    func setPosition(_ position: Position, in screen: NSScreen? = nil) {
        guard let visibleFrame = (screen ?? self.screen ?? NSScreen.main)?.visibleFrame else { return }

        let x: CGFloat
        switch position.horizontal {
        case .left:
            x = visibleFrame.minX + position.padding
        case .center:
            x = visibleFrame.midX - frame.width / 2
        case .right:
            x = visibleFrame.maxX - frame.width - position.padding
        }

        let y: CGFloat
        switch position.vertical {
        case .top:
            y = visibleFrame.maxY - frame.height - position.padding
        case .center:
            y = visibleFrame.midY - frame.height / 2
        case .bottom:
            y = visibleFrame.minY + position.padding
        }

        setFrameOrigin(CGPoint(x: x, y: y))
    }

    /// Convenience method for setting position with separate parameters.
    func setPosition(vertical: Position.Vertical, horizontal: Position.Horizontal, padding: CGFloat = 16) {
        setPosition(Position(vertical: vertical, horizontal: horizontal, padding: padding))
    }
}
```

This extension will be used to position the floating panel in a corner when first shown (before the user has saved a position).
  </action>
  <verify>File compiles: `swift build 2>&1 | head -20`</verify>
  <done>NSWindow+Position.swift exists with extension for corner positioning</done>
</task>

<task type="auto">
  <name>Task 2: Create FloatingPanel and FloatingWindowController</name>
  <files>Tokemon/Services/FloatingWindowController.swift</files>
  <action>
Create the floating panel infrastructure following the SettingsWindowController pattern:

```swift
import SwiftUI
import AppKit

/// Custom NSPanel configured for floating, always-on-top behavior.
/// Stays visible when app loses focus, doesn't steal focus when clicked.
class FloatingPanel: NSPanel {
    override init(contentRect: NSRect,
                  styleMask style: NSWindow.StyleMask,
                  backing backingStoreType: NSWindow.BackingStoreType,
                  defer flag: Bool) {
        super.init(contentRect: contentRect,
                   styleMask: [.titled, .closable, .fullSizeContentView, .nonactivatingPanel],
                   backing: backingStoreType,
                   defer: flag)

        // Core floating panel configuration
        self.isFloatingPanel = true
        self.level = .floating
        self.hidesOnDeactivate = false  // CRITICAL: Stay visible when app loses focus
        self.collectionBehavior = [.canJoinAllSpaces, .fullScreenAuxiliary]

        // Visual configuration
        self.titleVisibility = .hidden
        self.titlebarAppearsTransparent = true
        self.isMovableByWindowBackground = true
        self.isReleasedWhenClosed = false  // Keep in memory for reuse

        // Animation
        self.animationBehavior = .utilityWindow
    }

    // Allow becoming key for any interactive elements
    override var canBecomeKey: Bool { true }
}

/// Manages the floating usage window lifecycle.
/// Singleton service following the SettingsWindowController pattern.
@MainActor
final class FloatingWindowController {
    static let shared = FloatingWindowController()

    private var panel: FloatingPanel?
    private var monitor: UsageMonitor?
    private var alertManager: AlertManager?

    /// Auto-save name for position persistence
    private let frameAutosaveName = "TokemonFloatingWindow"

    private init() {}

    /// Set the monitor reference (call from app startup)
    func setMonitor(_ monitor: UsageMonitor) {
        self.monitor = monitor
    }

    /// Set the alert manager reference (call from app startup)
    func setAlertManager(_ manager: AlertManager) {
        self.alertManager = manager
    }

    /// Show the floating window, creating it if necessary.
    /// Position is restored from UserDefaults if previously saved.
    func showFloatingWindow() {
        if let existingPanel = panel {
            existingPanel.makeKeyAndOrderFront(nil)
            return
        }

        guard let monitor = monitor else {
            print("[Tokemon] Error: Monitor not set for floating window")
            return
        }

        guard let alertManager = alertManager else {
            print("[Tokemon] Error: AlertManager not set for floating window")
            return
        }

        // Create panel with compact size
        let newPanel = FloatingPanel(
            contentRect: NSRect(x: 0, y: 0, width: 140, height: 80),
            styleMask: [.titled, .closable, .fullSizeContentView, .nonactivatingPanel],
            backing: .buffered,
            defer: false
        )

        // Position persistence - MUST be set before showing window
        // This stores/restores position automatically in UserDefaults
        newPanel.setFrameAutosaveName(frameAutosaveName)

        // Set initial position if no saved position exists
        // Check if frame is at origin (no saved position)
        if newPanel.frame.origin == .zero {
            newPanel.setPosition(vertical: .top, horizontal: .right, padding: 20)
        }

        // Placeholder content - will be replaced in Plan 04-02
        let placeholderView = Text("Usage: --%")
            .font(.system(size: 24, weight: .bold, design: .rounded))
            .foregroundStyle(.secondary)
            .frame(width: 140, height: 80)
            .environment(monitor)
            .environment(alertManager)

        let hostingController = NSHostingController(rootView: placeholderView)
        newPanel.contentViewController = hostingController

        self.panel = newPanel
        newPanel.makeKeyAndOrderFront(nil)
    }

    /// Hide the floating window (close it)
    func hideFloatingWindow() {
        panel?.close()
    }

    /// Toggle floating window visibility
    func toggleFloatingWindow() {
        if isVisible {
            hideFloatingWindow()
        } else {
            showFloatingWindow()
        }
    }

    /// Whether the floating window is currently visible
    var isVisible: Bool {
        panel?.isVisible ?? false
    }
}
```

Key implementation details:
- FloatingPanel: NSPanel subclass with `hidesOnDeactivate = false` (research pitfall #1)
- `.nonactivatingPanel` style mask prevents focus stealing (research pitfall #2)
- `setFrameAutosaveName` called BEFORE showing (research pitfall #3)
- `isReleasedWhenClosed = false` keeps panel in memory for reuse
- `collectionBehavior = [.canJoinAllSpaces, .fullScreenAuxiliary]` for visibility across Spaces
- Placeholder content will be replaced with FloatingWindowView in Plan 04-02
  </action>
  <verify>
1. Build succeeds: `swift build 2>&1 | head -20`
2. No warnings about NSPanel configuration
  </verify>
  <done>FloatingPanel and FloatingWindowController exist, following SettingsWindowController pattern with proper NSPanel configuration for always-on-top behavior</done>
</task>

</tasks>

<verification>
1. `swift build` completes without errors
2. FloatingWindowController follows singleton pattern matching SettingsWindowController
3. FloatingPanel has all required configuration:
   - `isFloatingPanel = true`
   - `level = .floating`
   - `hidesOnDeactivate = false`
   - `.nonactivatingPanel` in styleMask
   - `setFrameAutosaveName` called before showing
4. NSWindow position extension provides corner positioning
</verification>

<success_criteria>
- FloatingPanel class exists with proper always-on-top configuration
- FloatingWindowController singleton manages panel lifecycle
- setMonitor/setAlertManager pattern matches SettingsWindowController
- Position persistence uses setFrameAutosaveName (automatic UserDefaults)
- Initial position defaults to top-right corner with padding
- NSWindow extension provides position helpers for any corner
</success_criteria>

<output>
After completion, create `.planning/phases/04-floating-window/04-01-SUMMARY.md`
</output>
