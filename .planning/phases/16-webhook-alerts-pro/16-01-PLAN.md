---
phase: 16-webhook-alerts-pro
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Tokemon/Models/WebhookConfig.swift
  - Tokemon/Services/WebhookManager.swift
  - Tokemon/Services/FeatureAccessManager.swift
  - Tokemon/Utilities/Constants.swift
autonomous: true

must_haves:
  truths:
    - "WebhookConfig model stores Slack URL, Discord URL, enabled flags, and message template settings"
    - "WebhookManager can send formatted payloads to Slack and Discord webhook URLs"
    - "WebhookManager respects per-service enabled flags and only sends to enabled destinations"
    - "WebhookManager formats messages differently for Slack (Block Kit) and Discord (embed)"
    - "Message template is customizable: user can choose which fields to include"
  artifacts:
    - path: "Tokemon/Models/WebhookConfig.swift"
      provides: "WebhookConfig struct with Slack/Discord URLs, enabled flags, and template fields"
      contains: "struct WebhookConfig"
    - path: "Tokemon/Services/WebhookManager.swift"
      provides: "WebhookManager service with sendAlert method for Slack and Discord"
      contains: "class WebhookManager"
    - path: "Tokemon/Services/FeatureAccessManager.swift"
      provides: "ProFeature.webhookAlerts case"
      contains: "webhookAlerts"
    - path: "Tokemon/Utilities/Constants.swift"
      provides: "UserDefaults keys for webhook config"
      contains: "webhookConfigKey"
  key_links:
    - from: "Tokemon/Services/WebhookManager.swift"
      to: "Tokemon/Models/WebhookConfig.swift"
      via: "WebhookManager reads WebhookConfig for URLs and template"
      pattern: "WebhookConfig"
---

<objective>
Create the webhook data model and service layer for sending usage alerts to Slack and Discord.

Purpose: Establishes the foundation for webhook alerts -- the config model that stores user preferences and the service that sends formatted HTTP POST requests to Slack/Discord webhook URLs.
Output: WebhookConfig model, WebhookManager service, ProFeature case for gating.
</objective>

<execution_context>
@/Users/richardparr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardparr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@Tokemon/Services/AlertManager.swift
@Tokemon/Services/FeatureAccessManager.swift
@Tokemon/Models/UsageSnapshot.swift
@Tokemon/Utilities/Constants.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: WebhookConfig model and Constants</name>
  <files>Tokemon/Models/WebhookConfig.swift, Tokemon/Utilities/Constants.swift</files>
  <action>
Create `Tokemon/Models/WebhookConfig.swift` with a `WebhookConfig` struct that is `Codable` and `Sendable`:

Properties:
- `slackWebhookURL: String` -- Slack incoming webhook URL (empty string = not configured)
- `discordWebhookURL: String` -- Discord webhook URL (empty string = not configured)
- `slackEnabled: Bool` -- whether Slack notifications are active (default false)
- `discordEnabled: Bool` -- whether Discord notifications are active (default false)
- `includePercentage: Bool` -- include usage percentage in message (default true)
- `includeResetTime: Bool` -- include time until reset (default true)
- `includeWeeklyUsage: Bool` -- include 7-day usage if available (default false)
- `includeProfileName: Bool` -- include which profile triggered the alert (default true)
- `customMessage: String` -- optional custom message prepended to alert (default empty)

Add a `static let `default`` property returning a config with all defaults.

Add computed properties:
- `hasSlack: Bool` -- slackEnabled && !slackWebhookURL.isEmpty
- `hasDiscord: Bool` -- discordEnabled && !discordWebhookURL.isEmpty
- `hasAnyWebhook: Bool` -- hasSlack || hasDiscord

Add save/load methods using UserDefaults with JSONEncoder/JSONDecoder, keyed on `Constants.webhookConfigKey`.

In `Constants.swift`, add:
- `static let webhookConfigKey = "tokemon.webhookConfig"` in a new `// MARK: - Webhook Alerts` section
  </action>
  <verify>`swift build` succeeds. Grep for `struct WebhookConfig` in the new file and `webhookConfigKey` in Constants.swift.</verify>
  <done>WebhookConfig model exists with all properties, defaults, computed helpers, and persistence via UserDefaults. Constants has the storage key.</done>
</task>

<task type="auto">
  <name>Task 2: WebhookManager service and ProFeature case</name>
  <files>Tokemon/Services/WebhookManager.swift, Tokemon/Services/FeatureAccessManager.swift</files>
  <action>
Create `Tokemon/Services/WebhookManager.swift` as an `@Observable @MainActor final class WebhookManager`:

Properties:
- `var config: WebhookConfig` -- loaded from UserDefaults on init, saved on change via didSet
- `@ObservationIgnored private var hasNotifiedWarning: Bool = false`
- `@ObservationIgnored private var hasNotifiedCritical: Bool = false`
- `@ObservationIgnored private var lastResetsAtMinute: Int = 0`

Init: Load config from UserDefaults (via WebhookConfig's load method). If nil, use `.default`.

Public methods:

1. `func checkUsageAndNotify(_ usage: UsageSnapshot, alertThreshold: Int)` -- mirrors AlertManager's logic:
   - Guard `usage.hasPercentage`, guard `config.hasAnyWebhook`
   - Detect window reset via `resetsAt` minute comparison (same logic as AlertManager) and reset notification flags
   - Calculate alert level: >= 100 = critical, >= alertThreshold = warning
   - If critical and !hasNotifiedCritical: set flag, call `sendWebhook(level: .critical, usage:)`
   - If warning and !hasNotifiedWarning: set flag, call `sendWebhook(level: .warning, usage:)`

2. `func resetNotificationState()` -- resets hasNotifiedWarning, hasNotifiedCritical

3. `func testWebhook(service: WebhookService) async throws` -- sends a test message to verify the webhook URL works. Use a friendly test payload. Throws on HTTP error.

4. `private func sendWebhook(level: AlertLevel, usage: UsageSnapshot)` -- fires Task to send to each enabled service concurrently

5. `private func sendSlackPayload(level: AlertLevel, usage: UsageSnapshot) async throws` -- POST to slackWebhookURL with JSON body using Slack Block Kit format:
   - Header block with emoji (warning: ":warning:", critical: ":rotating_light:") + "Usage Warning" or "Usage Limit Reached"
   - Section block with fields based on config template flags:
     - If includePercentage: "*Usage:* {percentage}%"
     - If includeResetTime and resetsAt exists: "*Resets:* {relative time like 'in 2h 15m'}"
     - If includeWeeklyUsage and sevenDayUtilization exists: "*Weekly:* {percentage}%"
     - If includeProfileName: "*Profile:* {profile name from UserDefaults activeProfileId or 'Default'}"
   - If customMessage is not empty: context block with the custom message
   - Content-Type: application/json

6. `private func sendDiscordPayload(level: AlertLevel, usage: UsageSnapshot) async throws` -- POST to discordWebhookURL with Discord embed format:
   - `embeds` array with one embed:
     - `title`: "Usage Warning" or "Usage Limit Reached"
     - `color`: 16776960 (yellow/warning) or 16711680 (red/critical)
     - `fields` array based on config template flags (same logic as Slack but using Discord field format: `{name, value, inline}`)
     - `footer.text`: "Tokemon"
     - `timestamp`: ISO 8601 current time
   - If customMessage not empty: add as `description` on the embed
   - Content-Type: application/json

7. `private func formatResetTime(_ date: Date) -> String` -- returns human-readable relative time like "in 2h 15m" or "in 45m"

Use `enum WebhookService: String, CaseIterable { case slack, discord }` and `enum AlertLevel { case warning, critical }` (can reuse naming from AlertManager but keep it local to avoid coupling).

Error handling: Log failures with `print("[WebhookManager] ...")` but do NOT throw from sendWebhook (fire-and-forget like AlertManager's notifications). Only testWebhook throws.

In `FeatureAccessManager.swift`, add to the `ProFeature` enum:
- `case webhookAlerts = "Slack & Discord webhook alerts"` after the teamDashboard case
- In the `icon` computed property switch, add: `case .webhookAlerts: return "bell.and.waves.left.and.right"`
  </action>
  <verify>`swift build` succeeds. Grep for `class WebhookManager` and `webhookAlerts` in the codebase.</verify>
  <done>WebhookManager service exists with Slack Block Kit and Discord embed formatting, threshold-based firing logic, test webhook capability, and fire-and-forget delivery. ProFeature.webhookAlerts case exists with icon.</done>
</task>

</tasks>

<verification>
- `swift build` succeeds with no errors
- `WebhookConfig` struct exists with all properties and persistence
- `WebhookManager` class exists with `checkUsageAndNotify`, `testWebhook`, Slack and Discord payload methods
- `ProFeature.webhookAlerts` case exists
- `Constants.webhookConfigKey` exists
</verification>

<success_criteria>
- WebhookConfig model stores all configuration for Slack/Discord webhooks with template customization
- WebhookManager can format and send payloads to both Slack (Block Kit) and Discord (embeds)
- Threshold logic mirrors AlertManager (fire once per level per usage window, reset on window change)
- Test webhook method allows users to verify their URL works
- ProFeature gate ready for UI integration
</success_criteria>

<output>
After completion, create `.planning/phases/16-webhook-alerts-pro/16-01-SUMMARY.md`
</output>
