---
phase: 01-foundation-core-monitoring
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - Tokemon/Services/OAuthClient.swift
  - Tokemon/Services/TokenManager.swift
  - Tokemon/Services/JSONLParser.swift
  - Tokemon/Services/UsageMonitor.swift
  - Tokemon/Models/UsageSnapshot.swift
autonomous: true

must_haves:
  truths:
    - "App fetches real usage data from OAuth endpoint using token from Keychain"
    - "App handles expired OAuth tokens by attempting refresh"
    - "App falls back to JSONL parsing when OAuth is unavailable"
    - "App can parse Claude Code JSONL logs from ~/.claude/projects/"
    - "Usage data refreshes automatically in the background"
    - "OAuth failure notifies user once then silently falls back to JSONL"
  artifacts:
    - path: "Tokemon/Services/OAuthClient.swift"
      provides: "HTTP client for /api/oauth/usage endpoint"
      exports: ["OAuthClient"]
    - path: "Tokemon/Services/TokenManager.swift"
      provides: "Keychain read, token expiry check, token refresh"
      exports: ["TokenManager"]
    - path: "Tokemon/Services/JSONLParser.swift"
      provides: "Defensive JSONL parser for ~/.claude/projects/ files"
      exports: ["JSONLParser"]
    - path: "Tokemon/Services/UsageMonitor.swift"
      provides: "Real data fetching replacing mock stubs"
      exports: ["UsageMonitor"]
  key_links:
    - from: "UsageMonitor.swift"
      to: "OAuthClient.swift"
      via: "async call in refresh()"
      pattern: "OAuthClient.*fetch"
    - from: "UsageMonitor.swift"
      to: "JSONLParser.swift"
      via: "fallback call in refresh()"
      pattern: "JSONLParser.*parse"
    - from: "OAuthClient.swift"
      to: "TokenManager.swift"
      via: "getAccessToken() before API call"
      pattern: "TokenManager.*getAccessToken"
    - from: "TokenManager.swift"
      to: "Keychain"
      via: "KeychainAccess library reading Claude Code-credentials"
      pattern: "Keychain.*Claude Code-credentials"
---

<objective>
Implement the real data layer: OAuth client that fetches usage from `api.anthropic.com`, TokenManager that reads/refreshes credentials from macOS Keychain, and JSONL parser that reads Claude Code session logs. Replace the mock data in UsageMonitor with real data fetching, including the OAuth-primary / JSONL-fallback chain and error handling per user decisions.

Purpose: This is the core value -- without real data, the app is just a shell. After this plan, the user sees their actual Claude usage.
Output: Working data pipeline from Keychain -> OAuth endpoint -> UsageSnapshot, with JSONL fallback.
</objective>

<execution_context>
@/Users/richardparr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardparr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-core-monitoring/01-RESEARCH.md
@.planning/phases/01-foundation-core-monitoring/01-CONTEXT.md
@.planning/phases/01-foundation-core-monitoring/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement TokenManager and OAuthClient</name>
  <files>
    Tokemon/Services/TokenManager.swift
    Tokemon/Services/OAuthClient.swift
  </files>
  <action>
**TokenManager.swift:**
- Import KeychainAccess
- Struct `TokenManager` (not a class -- stateless utility)
- Nested `ClaudeCredentials: Codable` matching the verified Keychain structure:
  ```
  { "claudeAiOauth": { "accessToken": String, "refreshToken": String, "expiresAt": Int64, "scopes": [String], "subscriptionType": String?, "rateLimitTier": String? } }
  ```
  Use `CodingKeys` for `claudeAiOauth` mapping (the key in the JSON is `claudeAiOauth` -- camelCase, which is the default, so no custom CodingKey needed for that. The nested fields: `accessToken`, `refreshToken`, `expiresAt`, `scopes`, `subscriptionType`, `rateLimitTier` -- all camelCase, matching Swift defaults).
- `TokenError` enum: `.noCredentials`, `.expired`, `.refreshFailed`, `.insufficientScope`, `.decodingError(Error)`
- `static func getCredentials() throws -> ClaudeCredentials`:
  - Create `Keychain(service: Constants.keychainService)` (which is "Claude Code-credentials")
  - Read with `try keychain.getString("")` (empty string key -- this is how Claude Code stores it, verified in research)
  - If nil, throw `.noCredentials`
  - Decode JSON into `ClaudeCredentials`. Wrap decode errors in `.decodingError`
  - Return credentials
- `static func getAccessToken() throws -> String`:
  - Call `getCredentials()`
  - Check `expiresAt`: convert from milliseconds (`Double(expiresAt) / 1000.0`) to Date. If expired (or within 10 minutes of expiry for proactive refresh), throw `.expired`
  - Check scopes array includes `"user:profile"`. If not, throw `.insufficientScope`
  - Return `accessToken`
- `static func getRefreshToken() throws -> String`:
  - Call `getCredentials()`, return `refreshToken`
- `static func refreshAccessToken(refreshToken: String) async throws -> OAuthTokenResponse`:
  - POST to `Constants.oauthTokenRefreshURL` ("https://console.anthropic.com/v1/oauth/token")
  - Body: `{ "grant_type": "refresh_token", "refresh_token": "{token}", "client_id": "{Constants.oauthClientId}" }`
  - Content-Type: application/json
  - Parse response into `OAuthTokenResponse` (new Codable struct): `accessToken: String`, `refreshToken: String`, `expiresIn: Int`, `tokenType: String`
  - Return the response
- `static func updateKeychainCredentials(response: OAuthTokenResponse) throws`:
  - Read current credentials from Keychain
  - Update the `accessToken`, `refreshToken`, and compute new `expiresAt` from `expiresIn`
  - Write updated JSON back to Keychain with `keychain.set(jsonString, key: "")`
  - **NOTE per research Open Question #3:** Writing back may conflict with Claude Code. Implement it but log a warning. If issues arise in testing, this can be disabled.

**OAuthClient.swift:**
- Struct `OAuthClient`
- `OAuthError` enum: `.invalidResponse`, `.tokenExpired`, `.insufficientScope`, `.httpError(Int, String?)`, `.networkError(Error)`
- `static func fetchUsage(accessToken: String) async throws -> OAuthUsageResponse`:
  - Build URLRequest for GET `Constants.oauthUsageURL`
  - Headers: `Authorization: Bearer {accessToken}`, `Accept: application/json`, `anthropic-beta: oauth-2025-04-20`, `User-Agent: Tokemon/1.0`
  - Execute with `URLSession.shared.data(for:)`
  - Handle status codes:
    - 200: decode `OAuthUsageResponse` and return
    - 401: throw `.tokenExpired`
    - 403: throw `.insufficientScope`
    - Other: throw `.httpError(statusCode, responseBodyString)`
  - Catch URLSession errors as `.networkError`
- `static func fetchUsageWithTokenRefresh() async throws -> OAuthUsageResponse`:
  - Try `TokenManager.getAccessToken()`. If `.expired`, attempt refresh:
    1. Get refresh token via `TokenManager.getRefreshToken()`
    2. Call `TokenManager.refreshAccessToken(refreshToken:)`
    3. Update Keychain via `TokenManager.updateKeychainCredentials(response:)`
    4. Use new access token
  - Call `fetchUsage(accessToken:)`
  - If 401 returned, attempt refresh once (same flow as above), then retry
  - If refresh fails, propagate the error
  </action>
  <verify>
`xcodebuild build` succeeds. Manually test by running the app -- if Claude Code credentials exist in Keychain, the OAuth fetch should succeed and return real usage data (visible in Console.app logs or Xcode console). If no credentials, the error path should trigger cleanly without crash.
  </verify>
  <done>
TokenManager reads Claude Code credentials from macOS Keychain, checks expiry with 10-minute proactive buffer, validates scopes, and can refresh expired tokens. OAuthClient fetches from /api/oauth/usage with proper headers, handles 401/403/errors, and includes automatic token refresh on expiry.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement JSONLParser and wire real data into UsageMonitor</name>
  <files>
    Tokemon/Services/JSONLParser.swift
    Tokemon/Services/UsageMonitor.swift
    Tokemon/Models/UsageSnapshot.swift
  </files>
  <action>
**JSONLParser.swift:**
- Struct `JSONLParser`
- Nested `SessionUsage` struct: `inputTokens: Int`, `outputTokens: Int`, `cacheCreationTokens: Int`, `cacheReadTokens: Int`, `model: String?`, `sessionId: String?`, `timestamp: Date?`
- Nested `AggregateUsage` struct: total of all SessionUsage values with computed `totalTokens: Int`
- `JSONLError` enum: `.noProjectsDirectory`, `.noSessionFiles`, `.parseError(Error)`
- `static func findProjectDirectories() throws -> [URL]`:
  - Expand `~/.claude/projects/` to absolute path
  - List contents of directory
  - Return directories (each is a project like `-Users-richardparr-Tokemon`)
- `static func findSessionFiles(in projectDir: URL, since: Date? = nil) -> [URL]`:
  - List `.jsonl` files in the project directory
  - If `since` provided, filter by file modification date (only files modified after `since`)
  - Sort by modification date descending (newest first)
  - Return URLs
- `static func parseSession(at url: URL) -> SessionUsage`:
  - Open file with `FileHandle(forReadingFrom:)`
  - Read entire file data, convert to String (UTF-8)
  - Split by newline, iterate each line
  - For each line: wrap in do/catch. Skip empty lines. Try `JSONSerialization.jsonObject(with:)` as `[String: Any]`
  - Only process lines where `type == "assistant"` AND `message.usage` exists
  - Accumulate: `input_tokens`, `output_tokens`, `cache_creation_input_tokens`, `cache_read_input_tokens` (all defaulting to 0 if missing)
  - Capture `model` from first assistant message, `sessionId` from first message with it
  - **CRITICAL: Defensive parsing per blocker.** Never force-unwrap. Every field access uses optional chaining with defaults. Skip lines that fail to decode. Log skipped lines count for debugging.
  - Return accumulated `SessionUsage`
- `static func parseRecentUsage(since: Date? = nil) throws -> AggregateUsage`:
  - Find all project directories
  - For each, find session files (optionally filtered by `since`)
  - Parse each session file
  - Aggregate all SessionUsage into AggregateUsage
  - If `since` is nil, default to sessions from the last 24 hours (to avoid parsing entire history)
- `static func toSnapshot(from aggregate: AggregateUsage) -> UsageSnapshot`:
  - JSONL does not provide utilization percentages (no limit info). Set `primaryPercentage` to -1 or use a sentinel to indicate "tokens only, no percentage available"
  - Populate token counts in the snapshot
  - Set `source = .jsonl`

**Update UsageSnapshot.swift:**
- Add a `hasPercentage: Bool` computed property (true if `primaryPercentage >= 0`)
- Add `formattedTokenCount: String` computed property that formats total tokens with comma separators
- Ensure the `menuBarText` returns token count (e.g., "12.4k") when source is JSONL and no percentage is available, vs "45%" when OAuth

**Update UsageMonitor.swift -- Replace mock data with real fetching:**
- Remove the mock data / random percentage logic from `refresh()`
- New `refresh()` implementation:
  1. Set `isRefreshing = true`, defer setting it to `false`
  2. **Try OAuth first** (if `oauthEnabled`):
     - Call `OAuthClient.fetchUsageWithTokenRefresh()`
     - On success: `currentUsage = response.toSnapshot()`, set `oauthState = .available`, `lastUpdated = Date()`, `error = nil`, return
     - On failure: set `oauthState = .failed(error)`, increment `oauthRetryCount`
     - **Error notification logic per user decision:** If this is the FIRST OAuth failure, post a user-visible notification message "Switching to backup data source" (store in a `oauthFailureNotified: Bool` flag). On subsequent failures, stay silent.
  3. **Try JSONL fallback** (if `jsonlEnabled`):
     - Call `JSONLParser.parseRecentUsage(since: fiveHoursAgo)` (match the 5-hour window)
     - On success: `currentUsage = JSONLParser.toSnapshot(from: aggregate)`, set `jsonlState = .available`, `lastUpdated = Date()`
     - On failure: set `jsonlState = .failed(error)`
  4. **Both failed:** set `error = .bothSourcesFailed(lastError)`. Increment `retryCount`. If `retryCount >= Constants.maxRetryAttempts` (3), stop auto-retrying (invalidate timer), set a flag `requiresManualRetry = true`.
- Add `var oauthRetryCount: Int = 0` and `var retryCount: Int = 0`
- Add `var requiresManualRetry: Bool = false`
- Add `var oauthFailureNotified: Bool = false`
- `manualRefresh()` method: resets `retryCount` to 0, `requiresManualRetry = false`, restarts polling, calls `refresh()`
- Ensure `startPolling()` calls `refresh()` immediately on start, then on timer
  </action>
  <verify>
`xcodebuild build` succeeds. Run the app with Claude Code credentials present in Keychain: the menu bar should show a real percentage from the OAuth endpoint. Check Xcode console for successful fetch logs. Test error path by temporarily using an invalid token (or disconnecting network): should see fallback to JSONL with token count display. Verify no crashes when parsing JSONL files (defensive parsing).
  </verify>
  <done>
OAuth client fetches real usage from api.anthropic.com. JSONL parser reads ~/.claude/projects/ session logs defensively. UsageMonitor implements the full priority chain: OAuth first, JSONL fallback, with retry logic (3 retries then manual). OAuth failure notification fires once then goes silent. Menu bar shows real percentage (OAuth) or token count (JSONL fallback).
  </done>
</task>

</tasks>

<verification>
- App shows REAL usage data (not mock) from OAuth endpoint
- If OAuth fails, app falls back to JSONL and shows token counts
- Token refresh works when access token is expired
- JSONL parser handles malformed lines without crashing
- Error handling follows user decision: notify once on OAuth failure, silent fallback thereafter
- Auto-retry stops after 3 attempts; manual retry resets the count
- Background polling continues when popover is closed
</verification>

<success_criteria>
- OAuthClient successfully fetches from /api/oauth/usage with Bearer auth
- TokenManager reads credentials from macOS Keychain (service: "Claude Code-credentials")
- TokenManager refreshes expired tokens via POST to /v1/oauth/token
- JSONLParser parses assistant message usage from .jsonl files without crashing on malformed data
- UsageMonitor implements OAuth-first, JSONL-fallback data chain
- Menu bar updates with real usage percentage from live data
- Error states handled per user decisions (notify once, silent fallback, 3 retries)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-monitoring/01-02-SUMMARY.md`
</output>
