---
phase: 19-dashboard-command
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - tokemon-raycast/src/types.ts
  - tokemon-raycast/src/utils.ts
  - tokemon-raycast/src/utils.test.ts
  - tokemon-raycast/src/api.ts
  - tokemon-raycast/package.json
  - tokemon-raycast/tsconfig.json
autonomous: true

must_haves:
  truths:
    - "UsageData interface matches the API response shape (five_hour, seven_day, etc.)"
    - "formatCountdown converts seconds to human-readable countdown (e.g. 3h 22m 14s)"
    - "computePace returns on-track, ahead, or behind based on elapsed window fraction vs utilization"
    - "parseResetDate safely parses ISO-8601 strings and returns null on invalid input"
    - "formatPercentage formats 0-100 number as percentage string"
    - "usageColor returns green/yellow/orange/red based on utilization threshold"
    - "fetchUsage returns typed UsageData instead of unknown"
  artifacts:
    - path: "tokemon-raycast/src/types.ts"
      provides: "UsageData, UsageWindow, ExtraUsage, PaceStatus type definitions"
      contains: "interface UsageData"
    - path: "tokemon-raycast/src/utils.ts"
      provides: "formatCountdown, computePace, parseResetDate, formatPercentage, usageColor"
      exports: ["formatCountdown", "computePace", "parseResetDate", "formatPercentage", "usageColor"]
    - path: "tokemon-raycast/src/utils.test.ts"
      provides: "Unit tests for all utility functions"
      contains: "describe"
  key_links:
    - from: "tokemon-raycast/src/utils.ts"
      to: "tokemon-raycast/src/types.ts"
      via: "imports PaceStatus type"
      pattern: "import.*PaceStatus.*from.*types"
    - from: "tokemon-raycast/src/api.ts"
      to: "tokemon-raycast/src/types.ts"
      via: "fetchUsage return type"
      pattern: "Promise<UsageData>"
---

<objective>
Create TypeScript types for the API response and pure utility functions for the dashboard, developed test-first.

Purpose: The dashboard needs typed API data and display logic (countdown formatting, pace calculation, color mapping). These are pure functions with clear I/O contracts -- ideal TDD candidates. Building them test-first ensures correctness before wiring into UI.

Output: `types.ts` with API response interfaces, `utils.ts` with 5 pure functions, `utils.test.ts` with passing tests, and `api.ts` updated to return `UsageData` instead of `unknown`.
</objective>

<execution_context>
@/Users/richardparr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardparr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-dashboard-command/19-RESEARCH.md

@tokemon-raycast/src/api.ts
@tokemon-raycast/src/constants.ts
@tokemon-raycast/src/index.tsx
@tokemon-raycast/package.json
@tokemon-raycast/tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create types and write failing tests for utility functions</name>
  <files>
    tokemon-raycast/src/types.ts
    tokemon-raycast/src/utils.ts
    tokemon-raycast/src/utils.test.ts
    tokemon-raycast/package.json
    tokemon-raycast/tsconfig.json
  </files>
  <action>
**Setup test runner:**
- Add `vitest` as a devDependency in package.json (lightweight, zero-config for TypeScript)
- Add `"test": "vitest run"` and `"test:watch": "vitest"` scripts to package.json
- Ensure tsconfig.json allows importing .ts files (already configured for bundler resolution, should work)

**Create types.ts** with interfaces mirroring the Swift OAuthUsageResponse:

```typescript
export interface UsageWindow {
  utilization: number;      // 0-100
  resets_at: string | null;  // ISO-8601
}

export interface ExtraUsage {
  is_enabled: boolean;
  monthly_limit: number | null;   // cents
  used_credits: number | null;    // cents
  utilization: number | null;     // 0-100
}

export interface UsageData {
  five_hour: UsageWindow | null;
  seven_day: UsageWindow | null;
  seven_day_oauth_apps: UsageWindow | null;
  seven_day_opus: UsageWindow | null;
  seven_day_sonnet: UsageWindow | null;
  extra_usage: ExtraUsage | null;
}

export type PaceStatus = "on-track" | "ahead" | "behind" | "unknown";
```

**Create utils.ts** with function signatures only (empty implementations that return wrong values to make tests fail):

```typescript
export function formatCountdown(seconds: number): string { return ""; }
export function computePace(utilization: number, resetsAt: Date | null): PaceStatus { return "unknown"; }
export function parseResetDate(iso: string | undefined | null): Date | null { return null; }
export function formatPercentage(pct: number | null | undefined): string { return ""; }
export function usageColor(pct: number): string { return ""; }
```

**Create utils.test.ts** with comprehensive tests (RED phase -- all must fail):

- `formatCountdown`:
  - `formatCountdown(0)` returns `"resetting"`
  - `formatCountdown(45)` returns `"45s"`
  - `formatCountdown(125)` returns `"2m 5s"`
  - `formatCountdown(3661)` returns `"1h 1m 1s"`
  - `formatCountdown(7200)` returns `"2h 0m 0s"`
  - `formatCountdown(-5)` returns `"resetting"`

- `computePace` (5-hour window = 18000000ms):
  - With 50% utilization and 50% elapsed: returns `"on-track"` (delta within 10)
  - With 80% utilization and 20% elapsed: returns `"behind"` (burning fast)
  - With 10% utilization and 80% elapsed: returns `"ahead"` (lots of headroom)
  - With null resetsAt: returns `"unknown"`
  - At exact boundary (delta = 10): returns `"on-track"` (not behind)
  - At exact boundary (delta = -10): returns `"on-track"` (not ahead)

- `parseResetDate`:
  - Valid ISO string returns a Date
  - `null` returns `null`
  - `undefined` returns `null`
  - `""` returns `null`
  - `"garbage"` returns `null`

- `formatPercentage`:
  - `formatPercentage(50)` returns `"50%"`
  - `formatPercentage(99.7)` returns `"100%"` (rounds)
  - `formatPercentage(0)` returns `"0%"`
  - `formatPercentage(null)` returns `"--"`
  - `formatPercentage(undefined)` returns `"--"`

- `usageColor` (uses string constants since no @raycast/api dependency):
  - In utils.ts, return plain color string names ("green", "yellow", "orange", "red")
  - The UI layer (index.tsx) will map these to Color.Green etc.
  - `usageColor(0)` returns `"green"`
  - `usageColor(39)` returns `"green"`
  - `usageColor(40)` returns `"yellow"`
  - `usageColor(69)` returns `"yellow"`
  - `usageColor(70)` returns `"orange"`
  - `usageColor(89)` returns `"orange"`
  - `usageColor(90)` returns `"red"`
  - `usageColor(100)` returns `"red"`

Run `npm test` in tokemon-raycast/ -- all tests MUST fail (RED).

Commit: `test(19-01): add failing tests for dashboard utility functions`
  </action>
  <verify>
Run `cd /Users/richardparr/tokemon-raycast && npm test` -- tests run but ALL fail (red phase). Zero passes expected (except parseResetDate null/undefined cases which match the stub).
  </verify>
  <done>types.ts has UsageData/UsageWindow/ExtraUsage/PaceStatus. utils.test.ts has 25+ test cases. utils.ts has stub implementations. All tests run, most fail.</done>
</task>

<task type="auto">
  <name>Task 2: Implement utilities to pass all tests, then update api.ts return type</name>
  <files>
    tokemon-raycast/src/utils.ts
    tokemon-raycast/src/api.ts
  </files>
  <action>
**GREEN phase -- implement utils.ts functions:**

`formatCountdown(seconds)`:
- If seconds <= 0, return "resetting"
- Calculate h, m, s from seconds
- If h > 0: return `${h}h ${m}m ${s}s`
- If m > 0: return `${m}m ${s}s`
- Return `${s}s`

`computePace(utilization, resetsAt)`:
- If resetsAt is null, return "unknown"
- Window is 5 hours (18000000 ms)
- elapsed = windowMs - (resetsAt.getTime() - Date.now())
- elapsedFraction = clamp(elapsed / windowMs, 0, 1)
- expectedUtilization = elapsedFraction * 100
- delta = utilization - expectedUtilization
- If delta > 10: "behind" (burning faster than window allows)
- If delta < -10: "ahead" (lots of headroom)
- Otherwise: "on-track"

`parseResetDate(iso)`:
- If !iso, return null
- Parse with `new Date(iso)`
- If isNaN(d.getTime()), return null
- Return d

`formatPercentage(pct)`:
- If pct is null or undefined, return "--"
- Return `${Math.round(pct)}%`

`usageColor(pct)`:
- >= 90: "red"
- >= 70: "orange"
- >= 40: "yellow"
- else: "green"

Note: utils.ts must have ZERO @raycast/api imports. It returns plain strings for colors. The UI layer maps to Raycast Color constants.

**Update api.ts:**
- Add `import type { UsageData } from "./types";` at the top
- Change `fetchUsage` return type from `Promise<unknown>` to `Promise<UsageData>`
- Change the final `return response.json();` to `return response.json() as Promise<UsageData>;`

Run `npm test` -- ALL tests must pass (GREEN).
Run `npm run build` -- build must succeed (api.ts type change compiles).

Commit: `feat(19-01): implement dashboard utilities and type fetchUsage response`

**REFACTOR phase (if needed):**
Review utils.ts for any cleanup. If changes made, run tests again to confirm still green, then commit: `refactor(19-01): clean up utility functions`
  </action>
  <verify>
Run `cd /Users/richardparr/tokemon-raycast && npm test` -- ALL tests pass (green).
Run `cd /Users/richardparr/tokemon-raycast && npm run build` -- build succeeds with no type errors.
  </verify>
  <done>All 25+ tests pass. fetchUsage returns Promise&lt;UsageData&gt;. npm run build succeeds. No @raycast/api imports in utils.ts or types.ts.</done>
</task>

</tasks>

<verification>
- `npm test` passes with all utility function tests green
- `npm run build` succeeds (TypeScript compiles with updated api.ts return type)
- types.ts has no @raycast/api imports (pure TypeScript, testable)
- utils.ts has no @raycast/api imports (pure functions, testable)
- api.ts return type is Promise<UsageData> (not Promise<unknown>)
</verification>

<success_criteria>
- UsageData interface matches Swift OAuthUsageResponse field names and types
- All utility functions have passing test coverage
- formatCountdown handles edge cases (0, negative, hours/minutes/seconds)
- computePace correctly categorizes usage pace with 10-point tolerance
- parseResetDate safely handles null/undefined/invalid inputs
- fetchUsage is now fully typed
</success_criteria>

<output>
After completion, create `.planning/phases/19-dashboard-command/19-01-SUMMARY.md`
</output>
