---
phase: 06-licensing-foundation
plan: 03
type: execute
wave: 3
depends_on: [06-01, 06-02]
files_modified:
  - ClaudeMon/Services/FeatureAccessManager.swift
  - ClaudeMon/ClaudeMonApp.swift
  - ClaudeMon/Views/MenuBar/PopoverContentView.swift
  - ClaudeMon/Views/Settings/DataSourceSettings.swift
autonomous: true

must_haves:
  truths:
    - "Pro features are gated behind license state check"
    - "Feature access is centralized in FeatureAccessManager"
    - "UI shows Pro badge or lock icons for gated features"
    - "Clicking locked feature prompts purchase"
    - "App remains functional with limited features when trial expires"
  artifacts:
    - path: "ClaudeMon/Services/FeatureAccessManager.swift"
      provides: "Centralized Pro feature gating"
      exports: ["FeatureAccessManager", "ProFeature"]
    - path: "ClaudeMon/ClaudeMonApp.swift"
      provides: "FeatureAccessManager integration"
      contains: "FeatureAccessManager"
  key_links:
    - from: "ClaudeMon/Services/FeatureAccessManager.swift"
      to: "ClaudeMon/Services/LicenseManager.swift"
      via: "License state observation"
      pattern: "LicenseManager"
    - from: "ClaudeMon/ClaudeMonApp.swift"
      to: "ClaudeMon/Services/FeatureAccessManager.swift"
      via: "@State property and environment"
      pattern: "@State.*featureAccess.*FeatureAccessManager"
---

<objective>
Create FeatureAccessManager for centralized Pro feature gating and integrate across UI.

Purpose: Establish clear Pro/Free feature boundaries that persist after trial expires while keeping the app functional.
Output: FeatureAccessManager service with feature enum, UI integration showing Pro badges and lock states.
</objective>

<execution_context>
@/Users/richardparr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardparr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/richardparr/ClaudeMon/.planning/PROJECT.md
@/Users/richardparr/ClaudeMon/.planning/phases/06-licensing-foundation/06-RESEARCH.md
@/Users/richardparr/ClaudeMon/.planning/phases/06-licensing-foundation/06-01-SUMMARY.md
@/Users/richardparr/ClaudeMon/.planning/phases/06-licensing-foundation/06-02-SUMMARY.md

Pro Features (v2):
- Multi-account support (Phase 7)
- Extended analytics & history (Phase 8)
- Export PDF/CSV (Phase 8)
- Shareable usage cards (Phase 9)

For Phase 6, we establish the gating infrastructure. Actual Pro features will be implemented in later phases but the gating mechanism must be ready.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FeatureAccessManager service</name>
  <files>ClaudeMon/Services/FeatureAccessManager.swift</files>
  <action>
    Create FeatureAccessManager.swift:

    ```swift
    import Foundation

    /// Enumeration of Pro-only features for centralized access control.
    /// Each feature maps to a v2 requirement and will be implemented in later phases.
    enum ProFeature: String, CaseIterable, Sendable {
        // Phase 7: Multi-Account
        case multiAccount = "Multiple Claude accounts"
        case accountSwitcher = "Account switcher"
        case perAccountAlerts = "Per-account alert thresholds"
        case combinedUsage = "Combined usage view"

        // Phase 8: Analytics & Export
        case extendedHistory = "30/90-day usage history"
        case weeklySummary = "Weekly usage summary"
        case monthlySummary = "Monthly usage summary"
        case projectBreakdown = "Project token breakdown"
        case exportPDF = "Export PDF reports"
        case exportCSV = "Export CSV data"

        // Phase 9: Shareable Moments
        case usageCards = "Shareable usage cards"

        /// User-friendly description for UI
        var displayName: String {
            rawValue
        }

        /// Icon for feature in UI
        var icon: String {
            switch self {
            case .multiAccount, .accountSwitcher:
                return "person.2.fill"
            case .perAccountAlerts:
                return "bell.badge.fill"
            case .combinedUsage:
                return "chart.pie.fill"
            case .extendedHistory:
                return "calendar"
            case .weeklySummary, .monthlySummary:
                return "chart.bar.fill"
            case .projectBreakdown:
                return "folder.fill"
            case .exportPDF, .exportCSV:
                return "square.and.arrow.up.fill"
            case .usageCards:
                return "photo.fill"
            }
        }
    }

    /// Centralized manager for Pro feature access control.
    /// Single source of truth for whether a feature should be enabled.
    @Observable
    @MainActor
    final class FeatureAccessManager {

        // MARK: - Dependencies

        @ObservationIgnored
        private let licenseManager: LicenseManager

        // MARK: - Computed State

        /// Whether the user has Pro access (trial, licensed, or grace period)
        var isPro: Bool {
            licenseManager.state.isProEnabled
        }

        /// Current license state (for UI display)
        var licenseState: LicenseState {
            licenseManager.state
        }

        /// Trial days remaining (nil if not on trial)
        var trialDaysRemaining: Int? {
            if case .onTrial(let days, _, _) = licenseManager.state {
                return days
            }
            return nil
        }

        /// Grace period days remaining (nil if not in grace period)
        var graceDaysRemaining: Int? {
            if case .gracePeriod(let days, _) = licenseManager.state {
                return days
            }
            return nil
        }

        // MARK: - Initialization

        init(licenseManager: LicenseManager) {
            self.licenseManager = licenseManager
        }

        // MARK: - Feature Access

        /// Check if a specific feature is accessible
        func canAccess(_ feature: ProFeature) -> Bool {
            isPro
        }

        /// Check if user should see an upgrade prompt for a feature
        func requiresPurchase(for feature: ProFeature) -> Bool {
            !isPro
        }

        /// Get all features that are currently locked
        var lockedFeatures: [ProFeature] {
            isPro ? [] : ProFeature.allCases
        }

        /// Get all features that are currently available
        var availableFeatures: [ProFeature] {
            isPro ? ProFeature.allCases : []
        }

        // MARK: - Actions

        /// Open purchase page (delegates to LicenseManager)
        func openPurchasePage() {
            licenseManager.openPurchasePage()
        }

        /// Open customer portal (delegates to LicenseManager)
        func openCustomerPortal() {
            licenseManager.openCustomerPortal()
        }
    }
    ```
  </action>
  <verify>
    - `swift build` succeeds
    - ProFeature enum has all v2 Pro features listed
    - FeatureAccessManager.isPro reflects license state correctly
    - canAccess() returns true when isPro is true, false otherwise
  </verify>
  <done>
    FeatureAccessManager provides centralized Pro feature gating with ProFeature enum covering all v2 Pro features.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate FeatureAccessManager at app level</name>
  <files>ClaudeMon/ClaudeMonApp.swift</files>
  <action>
    Update ClaudeMonApp.swift to initialize and distribute FeatureAccessManager:

    1. Add FeatureAccessManager as computed property (depends on LicenseManager):
       ```swift
       // After @State private var licenseManager:
       // Use computed property since it depends on licenseManager
       private var featureAccess: FeatureAccessManager {
           FeatureAccessManager(licenseManager: licenseManager)
       }
       ```

       Note: Actually, this should be @State to maintain instance identity. Better approach:
       ```swift
       @State private var featureAccess: FeatureAccessManager?

       // In init or first body evaluation, create it:
       // In menuBarExtraAccess callback after licenseManager is ready:
       if featureAccess == nil {
           featureAccess = FeatureAccessManager(licenseManager: licenseManager)
       }
       ```

       Even better - use lazy initialization pattern:
       ```swift
       // Make it @State with explicit initialization
       @State private var featureAccess: FeatureAccessManager

       init() {
           // Initialize before @State properties are set
           let license = LicenseManager()
           _licenseManager = State(initialValue: license)
           _featureAccess = State(initialValue: FeatureAccessManager(licenseManager: license))
           // ... rest of init
       }
       ```

    2. Pass FeatureAccessManager via environment alongside LicenseManager:
       ```swift
       // In MenuBarExtra content:
       .environment(featureAccess)

       // In Settings scene:
       .environment(featureAccess)
       ```

    3. Update SettingsWindowController to include FeatureAccessManager:
       ```swift
       SettingsWindowController.shared.setFeatureAccessManager(featureAccess)
       ```

    4. Update FloatingWindowController similarly if Pro features will appear there.

    The key change to ClaudeMonApp init:
    ```swift
    init() {
        // Initialize license and feature managers together
        let license = LicenseManager()
        _licenseManager = State(initialValue: license)
        _featureAccess = State(initialValue: FeatureAccessManager(licenseManager: license))

        // Existing notification delegate setup...
        if Bundle.main.bundleIdentifier != nil {
            UNUserNotificationCenter.current().delegate = AppDelegate.shared
        }
    }
    ```

    And update the @State declarations:
    ```swift
    @State private var licenseManager: LicenseManager
    @State private var featureAccess: FeatureAccessManager
    ```
    (Remove the inline initializers since init() handles it)
  </action>
  <verify>
    - `swift build` succeeds
    - App launches without crash
    - FeatureAccessManager is passed to child views via environment
  </verify>
  <done>
    FeatureAccessManager initialized at app level with proper dependency on LicenseManager; passed through SwiftUI environment to all views.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Pro badges and lock indicators to UI</name>
  <files>
    - ClaudeMon/Views/MenuBar/PopoverContentView.swift
    - ClaudeMon/Views/Settings/DataSourceSettings.swift
  </files>
  <action>
    For Phase 6, we add minimal UI hints about Pro features. Full Pro feature UI comes in later phases, but we establish the pattern now.

    1. Create a reusable ProBadge view (can add to Utilities or inline):
       ```swift
       /// Badge indicating a Pro-only feature
       struct ProBadge: View {
           var body: some View {
               Text("PRO")
                   .font(.caption2)
                   .fontWeight(.bold)
                   .foregroundStyle(.white)
                   .padding(.horizontal, 6)
                   .padding(.vertical, 2)
                   .background(
                       RoundedRectangle(cornerRadius: 4)
                           .fill(Color.orange.gradient)
                   )
           }
       }

       /// Lock icon for disabled Pro features
       struct ProLockIcon: View {
           var body: some View {
               Image(systemName: "lock.fill")
                   .font(.caption)
                   .foregroundStyle(.secondary)
           }
       }
       ```

    2. Update PopoverContentView.swift:
       - Add FeatureAccessManager environment
       - Show "Pro" status in header area when licensed (subtle indicator)

       Add environment:
       ```swift
       @Environment(FeatureAccessManager.self) private var featureAccess
       ```

       In the footer area (near gear menu), optionally show Pro badge when licensed:
       ```swift
       // After Spacer() and before refresh button in footer HStack:
       if case .licensed = featureAccess.licenseState {
           ProBadge()
       }
       ```

    3. Update DataSourceSettings.swift (example of future Pro feature placeholder):
       This is preparation for Phase 7 multi-account. For now, just add a comment section:

       ```swift
       // At end of Form, add a teaser section for Pro features:
       Section {
           HStack {
               Image(systemName: "person.2.fill")
                   .foregroundStyle(.secondary)
               Text("Multiple accounts")
               Spacer()
               if featureAccess.isPro {
                   Text("Coming in v2.1")
                       .font(.caption)
                       .foregroundStyle(.secondary)
               } else {
                   ProBadge()
               }
           }
           .opacity(0.6)
       } header: {
           Text("Pro Features")
       }
       ```

       Add environment:
       ```swift
       @Environment(FeatureAccessManager.self) private var featureAccess
       ```

    4. Add ProBadge and ProLockIcon to a shared location.
       Create ClaudeMon/Views/Components/ProBadge.swift:
       ```swift
       import SwiftUI

       /// Badge indicating a Pro-only feature
       struct ProBadge: View {
           var body: some View {
               Text("PRO")
                   .font(.caption2)
                   .fontWeight(.bold)
                   .foregroundStyle(.white)
                   .padding(.horizontal, 6)
                   .padding(.vertical, 2)
                   .background(
                       RoundedRectangle(cornerRadius: 4)
                           .fill(Color.orange.gradient)
                   )
           }
       }

       /// Lock icon overlay for disabled Pro features
       struct ProLockOverlay: View {
           let isLocked: Bool

           var body: some View {
               if isLocked {
                   Image(systemName: "lock.fill")
                       .font(.caption)
                       .foregroundStyle(.secondary)
                       .padding(4)
                       .background(.ultraThinMaterial, in: Circle())
               }
           }
       }

       /// View modifier to add Pro gating behavior
       struct ProGatedModifier: ViewModifier {
           let feature: ProFeature
           @Environment(FeatureAccessManager.self) private var featureAccess
           @State private var showingPurchasePrompt = false

           func body(content: Content) -> some View {
               content
                   .disabled(!featureAccess.canAccess(feature))
                   .overlay(alignment: .topTrailing) {
                       if !featureAccess.canAccess(feature) {
                           ProLockOverlay(isLocked: true)
                       }
                   }
                   .onTapGesture {
                       if !featureAccess.canAccess(feature) {
                           showingPurchasePrompt = true
                       }
                   }
                   .sheet(isPresented: $showingPurchasePrompt) {
                       PurchasePromptView()
                   }
           }
       }

       extension View {
           /// Apply Pro feature gating to a view
           func proGated(_ feature: ProFeature) -> some View {
               modifier(ProGatedModifier(feature: feature))
           }
       }
       ```

       Note: The proGated modifier is for future use - actual Pro features will use it in Phases 7-9.
  </action>
  <verify>
    - `swift build` succeeds
    - ProBadge appears in popover footer when licensed
    - DataSourceSettings shows "Pro Features" section with multi-account teaser
    - ProBadge and ProLockOverlay components are reusable
  </verify>
  <done>
    ProBadge and ProLockOverlay components created; FeatureAccessManager integrated in PopoverContentView and DataSourceSettings; .proGated() modifier ready for future Pro feature views.
  </done>
</task>

</tasks>

<verification>
1. `swift build` completes without errors
2. App launches and shows correct Pro/Free status
3. When on trial: popover shows trial banner, no Pro badge in footer
4. When licensed: popover shows Pro badge in footer area
5. When trial expired: features remain accessible but limited (core monitoring works)
6. DataSourceSettings shows Pro Features section with appropriate badges
7. FeatureAccessManager.isPro returns correct value based on license state
</verification>

<success_criteria>
- FeatureAccessManager provides centralized isPro check
- ProFeature enum lists all v2 Pro features (multi-account, analytics, export, cards)
- canAccess() method gates feature access based on license state
- ProBadge view component shows orange "PRO" badge
- ProLockOverlay shows lock icon on disabled features
- .proGated() view modifier ready for Phase 7-9 feature implementation
- App remains functional when trial expires (core monitoring still works)
- UI shows clear Pro/Free distinction without being intrusive
- FeatureAccessManager passed through environment to all views
</success_criteria>

<output>
After completion, create `.planning/phases/06-licensing-foundation/06-03-SUMMARY.md`
</output>
