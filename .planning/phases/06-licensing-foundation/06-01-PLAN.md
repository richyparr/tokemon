---
phase: 06-licensing-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Package.swift
  - ClaudeMon/Utilities/Constants.swift
  - ClaudeMon/Models/LicenseState.swift
  - ClaudeMon/Services/LicenseManager.swift
  - ClaudeMon/Services/LicenseStorage.swift
autonomous: true
user_setup:
  - service: lemonsqueezy
    why: "Payment processing and license management"
    env_vars: []
    constants_needed:
      - name: lemonSqueezyStoreId
        source: "LemonSqueezy Dashboard -> Settings -> Store"
      - name: lemonSqueezyProductId
        source: "LemonSqueezy Dashboard -> Products -> Your Product"
      - name: checkoutURL
        source: "LemonSqueezy Dashboard -> Products -> Share -> Checkout Link"
      - name: customerPortalURL
        source: "Format: https://YOURSTORE.lemonsqueezy.com/billing"

must_haves:
  truths:
    - "App validates license on launch without blocking UI"
    - "License key can be activated and stored securely"
    - "License validation succeeds when store_id and product_id match"
    - "Offline validation works for 7 days with cached state"
  artifacts:
    - path: "Package.swift"
      provides: "LemonSqueezyLicense dependency"
      contains: "swift-lemon-squeezy-license"
    - path: "ClaudeMon/Models/LicenseState.swift"
      provides: "License state machine enum"
      contains: "enum LicenseState"
    - path: "ClaudeMon/Services/LicenseManager.swift"
      provides: "Core licensing logic"
      exports: ["LicenseManager"]
    - path: "ClaudeMon/Services/LicenseStorage.swift"
      provides: "Secure Keychain storage for license data"
      contains: "KeychainAccess"
  key_links:
    - from: "ClaudeMon/Services/LicenseManager.swift"
      to: "ClaudeMon/Services/LicenseStorage.swift"
      via: "Keychain persistence"
      pattern: "LicenseStorage"
    - from: "ClaudeMon/Services/LicenseManager.swift"
      to: "LemonSqueezyLicense"
      via: "API activation/validation"
      pattern: "LemonSqueezyLicense"
---

<objective>
Create core licensing infrastructure with LemonSqueezy integration and secure state management.

Purpose: Establish the foundation for license activation, validation, and secure storage that all other licensing features depend on.
Output: LicenseManager service with Keychain-backed storage, following existing UsageMonitor pattern.
</objective>

<execution_context>
@/Users/richardparr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardparr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/richardparr/ClaudeMon/.planning/PROJECT.md
@/Users/richardparr/ClaudeMon/.planning/ROADMAP.md
@/Users/richardparr/ClaudeMon/.planning/phases/06-licensing-foundation/06-RESEARCH.md

Key patterns from existing code:
- UsageMonitor pattern: @Observable @MainActor with callbacks
- Keychain storage: KeychainAccess package already in project
- Constants: Centralized in Constants.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add LemonSqueezy package and constants</name>
  <files>
    - Package.swift
    - ClaudeMon/Utilities/Constants.swift
  </files>
  <action>
    1. Add swift-lemon-squeezy-license dependency to Package.swift:
       ```swift
       .package(url: "https://github.com/kevinhermawan/swift-lemon-squeezy-license.git", from: "1.0.1")
       ```
       Add "LemonSqueezyLicense" to target dependencies.

    2. Add LemonSqueezy constants to Constants.swift:
       ```swift
       // MARK: - LemonSqueezy Licensing

       /// LemonSqueezy store ID (verify against API responses)
       static let lemonSqueezyStoreId: Int = 0  // TODO: Replace with actual store ID

       /// LemonSqueezy product ID for ClaudeMon Pro
       static let lemonSqueezyProductId: Int = 0  // TODO: Replace with actual product ID

       /// LemonSqueezy checkout URL for purchasing
       static let lemonSqueezyCheckoutURL = "https://YOURSTORE.lemonsqueezy.com/buy/YOUR_PRODUCT_ID"

       /// LemonSqueezy customer portal URL for subscription management
       static let lemonSqueezyPortalURL = "https://YOURSTORE.lemonsqueezy.com/billing"

       /// Trial duration in days
       static let trialDurationDays: Int = 14

       /// Grace period for subscription lapses in days
       static let gracePeriodDays: Int = 7

       /// Offline validation window in days
       static let offlineValidationDays: Int = 7

       /// Keychain service name for license storage (separate from OAuth credentials)
       static let licenseKeychainService = "com.claudemon.license"
       ```

    Note: Store and product IDs are placeholders - user must replace before release.
  </action>
  <verify>
    - `swift build` completes without errors
    - Package.resolved includes swift-lemon-squeezy-license
  </verify>
  <done>
    LemonSqueezyLicense package available for import; constants defined for licensing configuration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create LicenseState model and LicenseStorage</name>
  <files>
    - ClaudeMon/Models/LicenseState.swift
    - ClaudeMon/Services/LicenseStorage.swift
  </files>
  <action>
    1. Create LicenseState.swift with state machine enum:
       ```swift
       import Foundation

       /// License status state machine with clear transitions.
       /// Each state indicates what features are available and what UI to show.
       enum LicenseState: Codable, Sendable, Equatable {
           case onTrial(daysRemaining: Int, startDate: Date, endDate: Date)
           case licensed(licenseKey: String, instanceId: String, expiresAt: Date?)
           case trialExpired
           case gracePeriod(daysRemaining: Int, licenseKey: String)
           case unlicensed

           /// Whether Pro features should be enabled
           var isProEnabled: Bool {
               switch self {
               case .onTrial, .licensed, .gracePeriod:
                   return true
               case .trialExpired, .unlicensed:
                   return false
               }
           }

           /// Display text for settings and status UI
           var displayText: String {
               switch self {
               case .onTrial(let days, _, _):
                   return "Trial: \(days) day\(days == 1 ? "" : "s") left"
               case .licensed(_, _, let expires):
                   if let exp = expires {
                       return "Pro (renews \(exp.formatted(date: .abbreviated, time: .omitted)))"
                   }
                   return "Pro"
               case .trialExpired:
                   return "Trial Expired"
               case .gracePeriod(let days, _):
                   return "Renew within \(days) day\(days == 1 ? "" : "s")"
               case .unlicensed:
                   return "Free"
               }
           }

           /// Short status for menu bar (only shown when relevant)
           var menuBarSuffix: String? {
               switch self {
               case .onTrial(let days, _, _) where days <= 3:
                   return "[\(days)d]"
               case .trialExpired:
                   return "[!]"
               case .gracePeriod(let days, _) where days <= 3:
                   return "[!\(days)d]"
               default:
                   return nil
               }
           }
       }

       /// Cached license data for persistence
       struct CachedLicenseData: Codable {
           let state: LicenseState
           let lastValidated: Date
           let licenseKey: String?
           let instanceId: String?
       }
       ```

    2. Create LicenseStorage.swift for secure Keychain storage:
       ```swift
       import Foundation
       import KeychainAccess
       import CryptoKit

       /// Secure storage for license and trial data using Keychain.
       /// Uses HMAC signatures to detect tampering with trial dates.
       actor LicenseStorage {
           static let shared = LicenseStorage()

           private let keychain: Keychain

           /// HMAC key for trial signature (compiled into binary)
           /// This prevents casual tampering - determined users can still bypass
           private let hmacKey: SymmetricKey

           private init() {
               keychain = Keychain(service: Constants.licenseKeychainService)
                   .accessibility(.afterFirstUnlockThisDeviceOnly)

               // Generate a stable HMAC key from app-specific data
               // In production, use a more sophisticated key derivation
               let keyData = "ClaudeMon-Trial-Signature-Key-v1".data(using: .utf8)!
               hmacKey = SymmetricKey(data: SHA256.hash(data: keyData))
           }

           // MARK: - Trial Storage

           struct TrialData: Codable {
               let startDate: Date
               let endDate: Date
               let signature: Data
           }

           /// Start a new trial period
           func startTrial() throws {
               // Check if trial already exists
               if try getTrialData() != nil {
                   return // Trial already started, don't reset
               }

               let start = Date()
               let end = start.addingTimeInterval(Double(Constants.trialDurationDays) * 24 * 60 * 60)
               let signature = computeTrialSignature(start: start, end: end)

               let trial = TrialData(startDate: start, endDate: end, signature: signature)
               let encoded = try JSONEncoder().encode(trial)
               try keychain.set(encoded, key: "trial")
           }

           /// Get trial state if valid
           func getTrialState() throws -> (daysRemaining: Int, startDate: Date, endDate: Date)? {
               guard let trial = try getTrialData() else { return nil }

               // Verify HMAC signature
               let expectedSig = computeTrialSignature(start: trial.startDate, end: trial.endDate)
               guard expectedSig == trial.signature else {
                   // Tampered - treat as expired
                   return (0, trial.startDate, trial.endDate)
               }

               let remaining = Calendar.current.dateComponents([.day], from: Date(), to: trial.endDate).day ?? 0
               return (max(0, remaining), trial.startDate, trial.endDate)
           }

           private func getTrialData() throws -> TrialData? {
               guard let data = try keychain.getData("trial") else { return nil }
               return try JSONDecoder().decode(TrialData.self, from: data)
           }

           private func computeTrialSignature(start: Date, end: Date) -> Data {
               let message = "\(start.timeIntervalSince1970)|\(end.timeIntervalSince1970)".data(using: .utf8)!
               let signature = HMAC<SHA256>.authenticationCode(for: message, using: hmacKey)
               return Data(signature)
           }

           // MARK: - License Storage

           /// Store activated license
           func storeLicense(key: String, instanceId: String, expiresAt: Date?) throws {
               let data = CachedLicenseData(
                   state: .licensed(licenseKey: key, instanceId: instanceId, expiresAt: expiresAt),
                   lastValidated: Date(),
                   licenseKey: key,
                   instanceId: instanceId
               )
               let encoded = try JSONEncoder().encode(data)
               try keychain.set(encoded, key: "license")
           }

           /// Get stored license data
           func getLicenseData() throws -> CachedLicenseData? {
               guard let data = try keychain.getData("license") else { return nil }
               return try JSONDecoder().decode(CachedLicenseData.self, from: data)
           }

           /// Update last validated timestamp
           func updateValidationTimestamp() throws {
               guard var data = try getLicenseData() else { return }
               data = CachedLicenseData(
                   state: data.state,
                   lastValidated: Date(),
                   licenseKey: data.licenseKey,
                   instanceId: data.instanceId
               )
               let encoded = try JSONEncoder().encode(data)
               try keychain.set(encoded, key: "license")
           }

           /// Clear all license data (for deactivation)
           func clearLicense() throws {
               try keychain.remove("license")
           }

           /// Clear trial data (for testing only)
           func clearTrial() throws {
               try keychain.remove("trial")
           }
       }
       ```
  </action>
  <verify>
    - `swift build` succeeds
    - LicenseState enum has all 5 cases: onTrial, licensed, trialExpired, gracePeriod, unlicensed
    - LicenseStorage uses Keychain with .afterFirstUnlockThisDeviceOnly
  </verify>
  <done>
    LicenseState model provides state machine with isProEnabled computed property; LicenseStorage provides secure Keychain persistence with HMAC-signed trial data.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create LicenseManager service</name>
  <files>ClaudeMon/Services/LicenseManager.swift</files>
  <action>
    Create LicenseManager.swift following UsageMonitor pattern:

    ```swift
    import Foundation
    import AppKit
    import LemonSqueezyLicense

    /// Licensing error types
    enum LicenseError: Error, LocalizedError {
        case activationFailed(String)
        case validationFailed(String)
        case wrongProduct
        case networkError(String)
        case deactivationFailed(String)

        var errorDescription: String? {
            switch self {
            case .activationFailed(let msg): return "Activation failed: \(msg)"
            case .validationFailed(let msg): return "Validation failed: \(msg)"
            case .wrongProduct: return "License key is for a different product"
            case .networkError(let msg): return "Network error: \(msg)"
            case .deactivationFailed(let msg): return "Deactivation failed: \(msg)"
            }
        }
    }

    /// Central license state manager following UsageMonitor pattern.
    /// Handles activation, validation, trial management, and grace periods.
    @Observable
    @MainActor
    final class LicenseManager {

        // MARK: - Published State

        /// Current license state
        var state: LicenseState = .unlicensed

        /// Whether validation is in progress
        var isValidating: Bool = false

        /// Timestamp of last successful validation
        var lastValidated: Date?

        /// Current error, if any
        var error: LicenseError?

        // MARK: - Callbacks

        /// Callback when state changes (for StatusItemManager)
        @ObservationIgnored
        var onStateChanged: ((LicenseState) -> Void)?

        // MARK: - Private

        @ObservationIgnored
        private let storage = LicenseStorage.shared

        @ObservationIgnored
        private let license = LemonSqueezyLicense()

        // MARK: - Initialization

        init() {
            // Load cached state synchronously for immediate UI
            Task { @MainActor in
                await loadCachedState()
                // Validate in background (non-blocking)
                Task {
                    await validateOnLaunch()
                }
            }
        }

        // MARK: - Public API

        /// Activate a license key
        func activateLicense(key: String) async throws {
            error = nil
            isValidating = true
            defer { isValidating = false }

            let trimmedKey = key.trimmingCharacters(in: .whitespacesAndNewlines)
            let instanceName = Host.current().localizedName ?? "Mac"

            do {
                let response = try await license.activate(key: trimmedKey, instanceName: instanceName)

                // Verify product ownership (critical security check)
                guard let meta = response.meta,
                      meta.storeId == Constants.lemonSqueezyStoreId,
                      meta.productId == Constants.lemonSqueezyProductId else {
                    throw LicenseError.wrongProduct
                }

                guard response.activated, let instance = response.instance else {
                    throw LicenseError.activationFailed(response.error ?? "Unknown error")
                }

                // Store license securely
                let expiresAt = response.licenseKey?.expiresAt
                try await storage.storeLicense(
                    key: trimmedKey,
                    instanceId: instance.id,
                    expiresAt: expiresAt
                )

                // Update state
                state = .licensed(licenseKey: trimmedKey, instanceId: instance.id, expiresAt: expiresAt)
                lastValidated = Date()
                onStateChanged?(state)

            } catch let licenseError as LicenseError {
                error = licenseError
                throw licenseError
            } catch {
                let licenseError = LicenseError.networkError(error.localizedDescription)
                self.error = licenseError
                throw licenseError
            }
        }

        /// Validate current license
        func validateLicense() async throws -> Bool {
            guard let cachedData = try await storage.getLicenseData(),
                  let key = cachedData.licenseKey,
                  let instanceId = cachedData.instanceId else {
                return false
            }

            isValidating = true
            defer { isValidating = false }

            do {
                let response = try await license.validate(key: key, instanceId: instanceId)

                guard response.valid else {
                    // Check if subscription expired (needs grace period)
                    if response.licenseKey?.status == "expired" {
                        enterGracePeriod(key: key)
                        return true
                    }
                    // License is invalid
                    state = .unlicensed
                    try await storage.clearLicense()
                    onStateChanged?(state)
                    return false
                }

                // Update cached validation timestamp
                try await storage.updateValidationTimestamp()
                lastValidated = Date()

                // Update state with fresh expiry info
                state = .licensed(
                    licenseKey: key,
                    instanceId: instanceId,
                    expiresAt: response.licenseKey?.expiresAt
                )
                onStateChanged?(state)
                return true

            } catch {
                // Network error - use offline fallback
                return handleOfflineValidation(cachedData: cachedData)
            }
        }

        /// Deactivate current license
        func deactivateLicense() async throws {
            guard let cachedData = try await storage.getLicenseData(),
                  let key = cachedData.licenseKey,
                  let instanceId = cachedData.instanceId else {
                return
            }

            do {
                _ = try await license.deactivate(key: key, instanceId: instanceId)
            } catch {
                // Log but continue - we'll clear local data anyway
                print("[LicenseManager] Deactivation API call failed: \(error)")
            }

            try await storage.clearLicense()
            state = .unlicensed
            lastValidated = nil
            onStateChanged?(state)
        }

        /// Open LemonSqueezy checkout page
        func openPurchasePage() {
            guard let url = URL(string: Constants.lemonSqueezyCheckoutURL) else { return }
            NSWorkspace.shared.open(url)
        }

        /// Open LemonSqueezy customer portal
        func openCustomerPortal() {
            guard let url = URL(string: Constants.lemonSqueezyPortalURL) else { return }
            NSWorkspace.shared.open(url)
        }

        // MARK: - Private Methods

        /// Load cached state on launch
        private func loadCachedState() async {
            // First check for existing license
            if let cached = try? await storage.getLicenseData() {
                state = cached.state
                lastValidated = cached.lastValidated
                return
            }

            // Then check for trial
            if let trial = try? await storage.getTrialState() {
                if trial.daysRemaining > 0 {
                    state = .onTrial(
                        daysRemaining: trial.daysRemaining,
                        startDate: trial.startDate,
                        endDate: trial.endDate
                    )
                } else {
                    state = .trialExpired
                }
                return
            }

            // No license or trial - start trial
            do {
                try await storage.startTrial()
                if let trial = try await storage.getTrialState() {
                    state = .onTrial(
                        daysRemaining: trial.daysRemaining,
                        startDate: trial.startDate,
                        endDate: trial.endDate
                    )
                }
            } catch {
                print("[LicenseManager] Failed to start trial: \(error)")
                state = .unlicensed
            }
        }

        /// Validate on app launch (non-blocking)
        private func validateOnLaunch() async {
            // Only validate if we have a license (not trial)
            guard case .licensed = state else {
                // Update trial days remaining
                if let trial = try? await storage.getTrialState() {
                    if trial.daysRemaining > 0 {
                        state = .onTrial(
                            daysRemaining: trial.daysRemaining,
                            startDate: trial.startDate,
                            endDate: trial.endDate
                        )
                    } else {
                        state = .trialExpired
                    }
                    onStateChanged?(state)
                }
                return
            }

            // Validate license in background
            _ = try? await validateLicense()
        }

        /// Enter grace period when subscription lapses
        private func enterGracePeriod(key: String) {
            let daysRemaining = Constants.gracePeriodDays
            state = .gracePeriod(daysRemaining: daysRemaining, licenseKey: key)
            onStateChanged?(state)
        }

        /// Handle offline validation using cached state
        private func handleOfflineValidation(cachedData: CachedLicenseData) -> Bool {
            let offlineWindow = TimeInterval(Constants.offlineValidationDays * 24 * 60 * 60)

            if Date().timeIntervalSince(cachedData.lastValidated) < offlineWindow {
                // Within offline window - trust cached state
                state = cachedData.state
                lastValidated = cachedData.lastValidated
                onStateChanged?(state)
                return true
            }

            // Offline window expired
            state = .unlicensed
            onStateChanged?(state)
            return false
        }
    }
    ```
  </action>
  <verify>
    - `swift build` succeeds
    - LicenseManager imports LemonSqueezyLicense without errors
    - LicenseManager has activateLicense, validateLicense, deactivateLicense methods
    - Initialization does not block (async validation)
  </verify>
  <done>
    LicenseManager provides complete licensing lifecycle: activation with product verification, background validation on launch, offline fallback, grace period handling, and customer portal links.
  </done>
</task>

</tasks>

<verification>
1. `swift build` completes without errors
2. `swift build 2>&1 | grep -i lemonsqueezy` confirms package is resolved
3. LicenseManager can be instantiated without crashes
4. Constants.swift contains all LemonSqueezy configuration values
</verification>

<success_criteria>
- LemonSqueezyLicense package added to Package.swift and builds successfully
- LicenseState enum with 5 states: onTrial, licensed, trialExpired, gracePeriod, unlicensed
- LicenseStorage actor provides secure Keychain storage with HMAC trial signatures
- LicenseManager service with @Observable @MainActor pattern matching UsageMonitor
- Product ID verification prevents cross-product license key acceptance
- Non-blocking validation on launch (UI shows cached state immediately)
- 7-day offline validation window for licensed users
- 7-day grace period for subscription lapses
</success_criteria>

<output>
After completion, create `.planning/phases/06-licensing-foundation/06-01-SUMMARY.md`
</output>
