---
phase: 12-menu-bar-customization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Tokemon/Models/MenuBarIconStyle.swift
  - Tokemon/Services/MenuBarIconRenderer.swift
  - Tokemon/Utilities/GradientColors.swift
  - Tokemon/TokemonApp.swift
autonomous: true

must_haves:
  truths:
    - "Menu bar displays a visual icon (not just text) when a non-percentage style is selected"
    - "Icon color shifts from neutral to amber to orange to red as usage increases"
    - "Monochrome mode renders the icon in system label color only"
    - "All 5 icon styles render correctly at menu bar size (18x18pt)"
  artifacts:
    - path: "Tokemon/Models/MenuBarIconStyle.swift"
      provides: "MenuBarIconStyle enum with 5 cases and AppStorage key"
      contains: "enum MenuBarIconStyle"
    - path: "Tokemon/Services/MenuBarIconRenderer.swift"
      provides: "NSImage rendering for each icon style at menu bar size"
      contains: "class MenuBarIconRenderer"
    - path: "Tokemon/TokemonApp.swift"
      provides: "StatusItemManager uses renderer for icon display"
      contains: "MenuBarIconRenderer"
  key_links:
    - from: "Tokemon/TokemonApp.swift"
      to: "Tokemon/Services/MenuBarIconRenderer.swift"
      via: "StatusItemManager.update calls renderer"
      pattern: "MenuBarIconRenderer\\.render"
    - from: "Tokemon/Services/MenuBarIconRenderer.swift"
      to: "Tokemon/Utilities/GradientColors.swift"
      via: "Color lookup for usage percentage"
      pattern: "GradientColors\\.color"
    - from: "Tokemon/Services/MenuBarIconRenderer.swift"
      to: "Tokemon/Models/MenuBarIconStyle.swift"
      via: "Switch on icon style to render"
      pattern: "MenuBarIconStyle"
---

<objective>
Create the menu bar icon rendering engine with 5 distinct styles and monochrome support.

Purpose: Replace the current text-only menu bar display with visual icon styles that communicate usage at a glance, fulfilling MENU-01 (5 styles), MENU-02 (monochrome), and MENU-03 (color reflects usage).

Output: MenuBarIconStyle model, MenuBarIconRenderer service, updated StatusItemManager that renders icons instead of plain attributed text.
</objective>

<execution_context>
@/Users/richardparr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardparr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@Tokemon/TokemonApp.swift
@Tokemon/Utilities/GradientColors.swift
@Tokemon/Models/UsageSnapshot.swift
@Tokemon/Views/Settings/AppearanceSettings.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: MenuBarIconStyle model and MenuBarIconRenderer service</name>
  <files>Tokemon/Models/MenuBarIconStyle.swift, Tokemon/Services/MenuBarIconRenderer.swift, Tokemon/Utilities/GradientColors.swift</files>
  <action>
Create `Tokemon/Models/MenuBarIconStyle.swift`:
- Define `enum MenuBarIconStyle: String, CaseIterable, Identifiable` with 5 cases:
  - `percentage` — text-only percentage display (current behavior, default)
  - `battery` — horizontal battery icon that fills based on usage
  - `progressBar` — thin vertical or horizontal progress bar
  - `iconAndBar` — small icon (lightning bolt or similar SF Symbol) plus a thin progress bar
  - `compact` — abbreviated percentage text with smaller font (e.g., "42" without the % sign)
- Each case has a `displayName: String` computed property for settings UI
- Each case has a `systemImage: String` for settings picker icons
- Add `id` property (rawValue)

Create `Tokemon/Services/MenuBarIconRenderer.swift`:
- Define `@MainActor struct MenuBarIconRenderer` with a static `render` method
- Method signature: `static func render(style: MenuBarIconStyle, percentage: Double, isMonochrome: Bool, hasData: Bool, suffix: String?) -> (image: NSImage?, title: NSAttributedString?)`
- The method returns EITHER an image (for visual styles) OR an attributed title (for text styles), never both
- For color: use `GradientColors.color(for: percentage)` when `isMonochrome` is false; use `NSColor.labelColor` when `isMonochrome` is true
- Menu bar icon size: 18x18pt, rendered as template image when monochrome

**Style rendering details:**

`percentage` style (text):
- Return nil image, attributed title with percentage text (current behavior)
- Use monospaced digit font size 12, medium weight
- Color from GradientColors (or labelColor if monochrome)
- Append suffix if present (license state)

`battery` style (image):
- Draw 18x18 NSImage using NSGraphicsContext/CGContext
- Battery outline: rounded rect ~16x10 centered vertically, with small nub on right (the battery terminal)
- Fill from left proportional to percentage
- Fill color from GradientColors (or 50% gray fill + labelColor outline if monochrome)
- Outline stroke 1pt

`progressBar` style (image):
- Draw 18x18 NSImage
- Thin horizontal bar (14x4pt) centered in the icon
- Background track in 20% opacity of label color
- Fill from left proportional to percentage
- Rounded ends (2pt corner radius)
- Fill color from GradientColors (or labelColor if monochrome)

`iconAndBar` style (image + text hybrid):
- Return nil image, attributed title with SF Symbol + percentage text
- Use NSAttributedString with NSTextAttachment for the SF Symbol (bolt.fill or similar)
- Follow with space + percentage text
- Color from GradientColors (or labelColor if monochrome)
- This style shows "bolt 42%" essentially

`compact` style (text):
- Return nil image, attributed title
- Just the number without % sign, e.g., "42"
- Monospaced digit font size 11, medium weight
- Color from GradientColors (or labelColor if monochrome)
- No suffix displayed (compact = minimal)

**Fallback when hasData is false:**
- Text styles: show "--"
- Image styles: show empty (0%) fill

Also update `GradientColors.swift`:
- Add a new static method `nsColor(for:isMonochrome:) -> NSColor` that wraps the existing `color(for:)` and handles the monochrome override. This keeps the monochrome logic centralized.
- The existing `color(for:)` method stays unchanged (backward compatible).
  </action>
  <verify>
Run `swift build` from the project root. The new files must compile without errors. Verify:
1. MenuBarIconStyle has exactly 5 cases
2. MenuBarIconRenderer.render returns the correct tuple type
3. GradientColors has both color(for:) and nsColor(for:isMonochrome:)
  </verify>
  <done>
MenuBarIconStyle enum has 5 cases (percentage, battery, progressBar, iconAndBar, compact). MenuBarIconRenderer.render produces the correct output type for each style. GradientColors supports monochrome override. All compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire renderer into StatusItemManager</name>
  <files>Tokemon/TokemonApp.swift</files>
  <action>
Update `StatusItemManager` in TokemonApp.swift to use the new renderer:

1. Add two `@ObservationIgnored` properties to StatusItemManager:
   - `private var currentStyle: MenuBarIconStyle` — read from UserDefaults key "menuBarIconStyle" (default: "percentage")
   - `private var isMonochrome: Bool` — read from UserDefaults key "menuBarMonochrome" (default: false)

2. Add a method `reloadSettings()` that re-reads both values from UserDefaults. This will be called when settings change.

3. Modify the `update(with:error:alertLevel:licenseState:)` method:
   - Compute the display percentage and suffix as before (keep the existing priority logic for error/alert states)
   - Call `MenuBarIconRenderer.render(style: currentStyle, percentage: ..., isMonochrome: isMonochrome, hasData: ..., suffix: ...)` to get the (image, title) tuple
   - If image is non-nil: set `button.image = image`, `button.imagePosition = .imageOnly`, clear `button.attributedTitle`
   - If title is non-nil: set `button.attributedTitle = title`, clear `button.image`
   - Keep `statusItem?.length = NSStatusItem.variableLength`

4. For error/critical states that need a "!" suffix:
   - For text styles: append "!" to the text as before
   - For image styles: we still need some visual indicator. Use a small red dot overlay in the image, OR fall back to adding a short text suffix. Simplest: for image styles, append a tiny "!" text after the image by setting both image AND title (imagePosition = .imageLeft).

5. Add a `NotificationCenter.default` observer in StatusItemManager for a custom notification name (e.g., `Notification.Name("MenuBarStyleChanged")`) that calls `reloadSettings()` and then re-runs `update()` with the last known usage data. Store the last usage/error/alertLevel/licenseState in properties so we can re-render on settings change.

The key change: StatusItemManager now stores the last update parameters and can re-render when the icon style changes, not just when usage data changes.
  </action>
  <verify>
Run `swift build` from the project root. Verify:
1. StatusItemManager reads menuBarIconStyle and menuBarMonochrome from UserDefaults
2. StatusItemManager.update calls MenuBarIconRenderer.render
3. Button image or attributedTitle is set based on render output
4. Settings change notification triggers re-render
  </verify>
  <done>
StatusItemManager renders menu bar using MenuBarIconRenderer based on user's style preference. Text styles show colored percentage text, image styles show visual icons. Monochrome mode renders in system label color. Settings changes trigger immediate re-render. Error/alert indicators still visible for all styles.
  </done>
</task>

</tasks>

<verification>
1. `swift build` passes with zero errors
2. The app can be launched and displays the default percentage style (backward compatible)
3. Manually changing UserDefaults `menuBarIconStyle` to "battery" shows a battery icon in the menu bar
4. Manually changing UserDefaults `menuBarMonochrome` to true shows monochrome rendering
</verification>

<success_criteria>
- 5 icon styles defined in MenuBarIconStyle enum
- MenuBarIconRenderer produces visual output for all 5 styles
- StatusItemManager uses renderer instead of hardcoded text rendering
- Monochrome mode supported (labelColor instead of gradient colors)
- Usage-based color (green/amber/orange/red) applied to all styles
- Backward compatible: default "percentage" style matches previous behavior
- Clean compilation with `swift build`
</success_criteria>

<output>
After completion, create `.planning/phases/12-menu-bar-customization/12-01-SUMMARY.md`
</output>
