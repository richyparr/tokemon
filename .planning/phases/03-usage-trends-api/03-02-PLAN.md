---
phase: 03-usage-trends-api
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - ClaudeMon/Services/BurnRateCalculator.swift
  - ClaudeMon/Views/Charts/UsageChartView.swift
  - ClaudeMon/Views/Charts/BurnRateView.swift
  - ClaudeMon/Views/MenuBar/PopoverContentView.swift
autonomous: true

must_haves:
  truths:
    - "User can see a usage chart showing trends over time"
    - "User can toggle between 24h and 7d time ranges"
    - "User can see current burn rate as percentage per hour"
    - "User can see estimated time until limit at current pace"
  artifacts:
    - path: "ClaudeMon/Services/BurnRateCalculator.swift"
      provides: "Burn rate calculation and time-to-limit projection"
      contains: "struct BurnRateCalculator"
    - path: "ClaudeMon/Views/Charts/UsageChartView.swift"
      provides: "Swift Charts line/area visualization"
      contains: "import Charts"
    - path: "ClaudeMon/Views/Charts/BurnRateView.swift"
      provides: "Burn rate and projection display"
      contains: "struct BurnRateView"
  key_links:
    - from: "ClaudeMon/Views/Charts/UsageChartView.swift"
      to: "ClaudeMon/Services/UsageMonitor.swift"
      via: "usageHistory binding"
      pattern: "monitor\\.usageHistory"
    - from: "ClaudeMon/Views/Charts/BurnRateView.swift"
      to: "ClaudeMon/Services/BurnRateCalculator.swift"
      via: "burn rate calculation"
      pattern: "BurnRateCalculator\\."
    - from: "ClaudeMon/Views/MenuBar/PopoverContentView.swift"
      to: "ClaudeMon/Views/Charts/UsageChartView.swift"
      via: "embedded chart view"
      pattern: "UsageChartView"
---

<objective>
Build the usage trend visualization and burn rate projection UI.

Purpose: Let users see their usage patterns over time and understand when they might hit their limit at the current pace. This fulfills TREND-02, TREND-03, TREND-04, and TREND-05.

Output: UsageChartView with Swift Charts, BurnRateCalculator for pace/projection math, BurnRateView for display, all integrated into the popover.
</objective>

<execution_context>
@/Users/richardparr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardparr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-usage-trends-api/03-RESEARCH.md
@.planning/phases/03-usage-trends-api/03-01-SUMMARY.md

# Existing patterns
@ClaudeMon/Views/MenuBar/PopoverContentView.swift
@ClaudeMon/Services/UsageMonitor.swift
@ClaudeMon/Models/UsageDataPoint.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BurnRateCalculator</name>
  <files>ClaudeMon/Services/BurnRateCalculator.swift</files>
  <action>
Create a utility struct for burn rate calculations:

```swift
import Foundation

/// Calculates usage burn rate and projects time-to-limit.
/// Uses a rolling window approach for stable estimates (avoids volatility pitfall from research).
struct BurnRateCalculator {

    /// Calculate burn rate (percentage per hour) from recent data points.
    /// Uses a 2-hour rolling window for stability.
    ///
    /// - Parameter points: Historical usage data points (should be sorted by timestamp)
    /// - Parameter windowHours: Rolling window size (default 2 hours per research recommendation)
    /// - Returns: Burn rate as percentage per hour, or nil if insufficient data
    static func calculateBurnRate(
        from points: [UsageDataPoint],
        windowHours: Double = 2.0
    ) -> Double? {
        let cutoff = Date().addingTimeInterval(-windowHours * 3600)
        let recentPoints = points.filter { $0.timestamp > cutoff }

        // Need at least 2 points to calculate a rate
        guard recentPoints.count >= 2,
              let first = recentPoints.first,
              let last = recentPoints.last else {
            return nil
        }

        let usageDelta = last.primaryPercentage - first.primaryPercentage
        let timeDeltaHours = last.timestamp.timeIntervalSince(first.timestamp) / 3600

        // Avoid division by zero
        guard timeDeltaHours > 0.01 else { return nil }  // At least ~36 seconds

        return usageDelta / timeDeltaHours  // % per hour
    }

    /// Project time until 100% limit at current burn rate.
    ///
    /// - Parameter currentUsage: Current usage percentage (0-100)
    /// - Parameter burnRate: Burn rate in percentage per hour
    /// - Returns: Time interval until limit, or nil if not approaching limit
    static func projectTimeToLimit(
        currentUsage: Double,
        burnRate: Double
    ) -> TimeInterval? {
        // If not burning (idle or decreasing), no limit ETA
        guard burnRate > 0.01 else { return nil }

        let remainingPercentage = 100.0 - currentUsage
        guard remainingPercentage > 0 else { return nil }  // Already at limit

        let hoursRemaining = remainingPercentage / burnRate
        return hoursRemaining * 3600  // Convert to seconds
    }

    /// Format time interval for display (e.g., "2h 30m", "45m", ">24h").
    static func formatTimeRemaining(_ seconds: TimeInterval) -> String {
        guard seconds > 0 else { return "--" }

        if seconds > 24 * 3600 {
            return ">24h"
        }

        let hours = Int(seconds) / 3600
        let minutes = (Int(seconds) % 3600) / 60

        if hours > 0 {
            return "\(hours)h \(minutes)m"
        }
        return "\(minutes)m"
    }

    /// Determine color for burn rate indicator.
    static func burnRateColor(rate: Double?) -> BurnRateLevel {
        guard let rate = rate else { return .unknown }
        if rate > 20 { return .critical }   // >20%/hr = hitting limit fast
        if rate > 10 { return .elevated }   // 10-20%/hr = moderate pace
        return .normal                       // <10%/hr = sustainable
    }

    enum BurnRateLevel {
        case normal, elevated, critical, unknown
    }
}
```

Key design choices:
- 2-hour window per research recommendation (avoids volatility)
- Static methods for simple utility usage
- Separate color/level logic for UI styling
  </action>
  <verify>File compiles: `swift build 2>&1 | head -20`</verify>
  <done>BurnRateCalculator.swift exists with calculateBurnRate, projectTimeToLimit, and formatting helpers</done>
</task>

<task type="auto">
  <name>Task 2: Create UsageChartView with Swift Charts</name>
  <files>ClaudeMon/Views/Charts/UsageChartView.swift</files>
  <action>
Create a new `Charts` folder under `Views` if needed, then create UsageChartView:

```swift
import SwiftUI
import Charts

/// Time range options for the usage chart.
enum ChartTimeRange: String, CaseIterable {
    case day = "24h"
    case week = "7d"

    var interval: TimeInterval {
        switch self {
        case .day: return 24 * 3600
        case .week: return 7 * 24 * 3600
        }
    }

    var strideComponent: Calendar.Component {
        switch self {
        case .day: return .hour
        case .week: return .day
        }
    }

    var strideCount: Int {
        switch self {
        case .day: return 4    // Every 4 hours
        case .week: return 1   // Every day
        }
    }
}

/// Usage trend chart with area fill and line overlay.
/// Uses Swift Charts (native macOS 13+, project targets macOS 14+).
struct UsageChartView: View {
    let dataPoints: [UsageDataPoint]
    @State private var selectedRange: ChartTimeRange = .day

    private var filteredPoints: [UsageDataPoint] {
        let cutoff = Date().addingTimeInterval(-selectedRange.interval)
        return dataPoints.filter { $0.timestamp > cutoff }
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // Range selector
            HStack {
                Text("Usage Trend")
                    .font(.headline)
                Spacer()
                Picker("", selection: $selectedRange) {
                    ForEach(ChartTimeRange.allCases, id: \.self) { range in
                        Text(range.rawValue).tag(range)
                    }
                }
                .pickerStyle(.segmented)
                .frame(width: 100)
            }

            if filteredPoints.isEmpty {
                // Empty state
                VStack(spacing: 8) {
                    Image(systemName: "chart.line.downtrend.xyaxis")
                        .font(.largeTitle)
                        .foregroundStyle(.secondary)
                    Text("No data yet")
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
                .frame(height: 120)
                .frame(maxWidth: .infinity)
            } else {
                // Chart
                Chart {
                    ForEach(filteredPoints) { point in
                        // Area fill (gradient)
                        AreaMark(
                            x: .value("Time", point.timestamp),
                            y: .value("Usage", point.primaryPercentage)
                        )
                        .foregroundStyle(
                            LinearGradient(
                                colors: [.blue.opacity(0.4), .blue.opacity(0.1)],
                                startPoint: .top,
                                endPoint: .bottom
                            )
                        )
                        .interpolationMethod(.catmullRom)

                        // Line overlay
                        LineMark(
                            x: .value("Time", point.timestamp),
                            y: .value("Usage", point.primaryPercentage)
                        )
                        .foregroundStyle(.blue)
                        .lineStyle(StrokeStyle(lineWidth: 2))
                        .interpolationMethod(.catmullRom)
                    }
                }
                .chartXAxis {
                    AxisMarks(values: .stride(
                        by: selectedRange.strideComponent,
                        count: selectedRange.strideCount
                    )) { value in
                        AxisGridLine()
                        AxisValueLabel(format: selectedRange == .day
                            ? .dateTime.hour(.defaultDigits(amPM: .abbreviated))
                            : .dateTime.weekday(.abbreviated)
                        )
                    }
                }
                .chartYAxis {
                    AxisMarks(position: .leading, values: [0, 25, 50, 75, 100]) { value in
                        AxisGridLine()
                        AxisValueLabel {
                            if let pct = value.as(Double.self) {
                                Text("\(Int(pct))%")
                                    .font(.caption2)
                            }
                        }
                    }
                }
                .chartYScale(domain: 0...100)
                .frame(height: 120)
            }
        }
    }
}

#Preview {
    // Generate sample data
    let sampleData: [UsageDataPoint] = (0..<24).map { hoursAgo in
        UsageDataPoint(
            timestamp: Date().addingTimeInterval(-Double(hoursAgo) * 3600),
            primaryPercentage: Double.random(in: 20...80)
        )
    }
    return UsageChartView(dataPoints: sampleData)
        .padding()
        .frame(width: 320)
}
```

Key design choices:
- Segmented picker for 24h/7d toggle
- AreaMark + LineMark combo per research Pattern 4
- catmullRom interpolation for smooth curves
- Y-axis locked to 0-100% scale
- Empty state for new users
  </action>
  <verify>File compiles: `swift build 2>&1 | head -20`</verify>
  <done>UsageChartView.swift exists with Swift Charts visualization and time range selector</done>
</task>

<task type="auto">
  <name>Task 3: Create BurnRateView and integrate into popover</name>
  <files>
    ClaudeMon/Views/Charts/BurnRateView.swift
    ClaudeMon/Views/MenuBar/PopoverContentView.swift
  </files>
  <action>
**Part A: Create BurnRateView**

Create `ClaudeMon/Views/Charts/BurnRateView.swift`:

```swift
import SwiftUI

/// Displays current burn rate and projected time to limit.
struct BurnRateView: View {
    let currentUsage: Double
    let dataPoints: [UsageDataPoint]

    private var burnRate: Double? {
        BurnRateCalculator.calculateBurnRate(from: dataPoints)
    }

    private var timeToLimit: TimeInterval? {
        guard let rate = burnRate else { return nil }
        return BurnRateCalculator.projectTimeToLimit(currentUsage: currentUsage, burnRate: rate)
    }

    private var burnRateLevel: BurnRateCalculator.BurnRateLevel {
        BurnRateCalculator.burnRateColor(rate: burnRate)
    }

    private var levelColor: Color {
        switch burnRateLevel {
        case .normal: return .green
        case .elevated: return .orange
        case .critical: return .red
        case .unknown: return .secondary
        }
    }

    var body: some View {
        HStack(spacing: 16) {
            // Burn rate
            VStack(alignment: .leading, spacing: 2) {
                HStack(spacing: 4) {
                    Image(systemName: "flame.fill")
                        .foregroundColor(levelColor)
                        .font(.caption)
                    Text("Burn Rate")
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
                if let rate = burnRate {
                    Text(String(format: "%.1f%%/hr", rate))
                        .font(.system(.body, design: .monospaced))
                } else {
                    Text("--")
                        .font(.system(.body, design: .monospaced))
                        .foregroundStyle(.secondary)
                }
            }

            Divider()
                .frame(height: 30)

            // Time to limit
            VStack(alignment: .leading, spacing: 2) {
                HStack(spacing: 4) {
                    Image(systemName: "clock")
                        .foregroundColor(timeToLimitColor)
                        .font(.caption)
                    Text("Limit In")
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
                if let time = timeToLimit {
                    Text(BurnRateCalculator.formatTimeRemaining(time))
                        .font(.system(.body, design: .monospaced))
                        .foregroundColor(timeToLimitColor)
                } else {
                    Text("--")
                        .font(.system(.body, design: .monospaced))
                        .foregroundStyle(.secondary)
                }
            }

            Spacer()
        }
        .padding(.vertical, 4)
    }

    private var timeToLimitColor: Color {
        guard let time = timeToLimit else { return .secondary }
        if time < 3600 { return .red }          // <1 hour
        if time < 2 * 3600 { return .orange }   // <2 hours
        return .primary
    }
}

#Preview {
    let sampleData: [UsageDataPoint] = [
        UsageDataPoint(timestamp: Date().addingTimeInterval(-7200), primaryPercentage: 30),
        UsageDataPoint(timestamp: Date().addingTimeInterval(-3600), primaryPercentage: 45),
        UsageDataPoint(timestamp: Date(), primaryPercentage: 60)
    ]
    return BurnRateView(currentUsage: 60, dataPoints: sampleData)
        .padding()
        .frame(width: 320)
}
```

**Part B: Integrate into PopoverContentView**

Modify `ClaudeMon/Views/MenuBar/PopoverContentView.swift`:

1. Add imports at top if not present:
```swift
import Charts  // (may already have SwiftUI)
```

2. In the body, after UsageDetailView and before Spacer, add the chart and burn rate sections:

```swift
// After UsageDetailView(usage: monitor.currentUsage, showExtraUsage: monitor.showExtraUsage)

// Usage trends section (only show if we have OAuth data with percentage)
if monitor.currentUsage.hasPercentage {
    Divider()

    // Chart
    UsageChartView(dataPoints: monitor.usageHistory)

    // Burn rate
    BurnRateView(
        currentUsage: monitor.currentUsage.primaryPercentage,
        dataPoints: monitor.usageHistory
    )
}
```

This conditionally shows the chart only when OAuth data is available (hasPercentage == true), since JSONL fallback doesn't provide meaningful percentage data for charting.
  </action>
  <verify>
1. Build succeeds: `swift build 2>&1 | head -20`
2. Launch app, click menu bar icon
3. Popover shows chart and burn rate section (may show empty state if no history yet)
  </verify>
  <done>
- BurnRateView.swift shows burn rate and time-to-limit
- PopoverContentView includes UsageChartView and BurnRateView
- Chart only appears when OAuth data is available
  </done>
</task>

</tasks>

<verification>
1. `swift build` completes without errors
2. App launches without crash
3. Click menu bar icon - popover displays chart section
4. Chart shows empty state initially, then populates as data accumulates
5. Time range picker switches between 24h and 7d views
6. Burn rate shows percentage per hour after 2+ data points
7. Time-to-limit shows estimate when actively using Claude
</verification>

<success_criteria>
- Swift Charts visualization renders usage trends
- User can toggle between 24h and 7d time ranges
- Burn rate displays as X.X%/hr with color coding
- Time-to-limit shows formatted estimate (e.g., "2h 30m")
- Empty states handle gracefully for new users
- Chart integrates cleanly into existing popover layout
</success_criteria>

<output>
After completion, create `.planning/phases/03-usage-trends-api/03-02-SUMMARY.md`
</output>
