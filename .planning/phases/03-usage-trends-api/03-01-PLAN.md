---
phase: 03-usage-trends-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ClaudeMon/Models/UsageDataPoint.swift
  - ClaudeMon/Services/HistoryStore.swift
  - ClaudeMon/Services/UsageMonitor.swift
autonomous: true

must_haves:
  truths:
    - "Usage snapshots are recorded every time UsageMonitor successfully refreshes"
    - "Historical data persists across app launches"
    - "History is automatically trimmed to 30 days"
  artifacts:
    - path: "ClaudeMon/Models/UsageDataPoint.swift"
      provides: "Time-series data point model"
      contains: "struct UsageDataPoint"
    - path: "ClaudeMon/Services/HistoryStore.swift"
      provides: "Thread-safe JSON persistence"
      contains: "actor HistoryStore"
  key_links:
    - from: "ClaudeMon/Services/UsageMonitor.swift"
      to: "ClaudeMon/Services/HistoryStore.swift"
      via: "append call after successful refresh"
      pattern: "historyStore.*append"
    - from: "ClaudeMon/Services/HistoryStore.swift"
      to: "Application Support/ClaudeMon/usage_history.json"
      via: "JSON file I/O"
      pattern: "usage_history\\.json"
---

<objective>
Create the historical data persistence layer for usage tracking.

Purpose: Enable storing usage snapshots over time so charts and burn rate calculations have data to work with. This is the foundation for all trend visualization in Plan 03-02.

Output: UsageDataPoint model, HistoryStore actor with JSON persistence, and UsageMonitor integration that records every successful refresh.
</objective>

<execution_context>
@/Users/richardparr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardparr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-usage-trends-api/03-RESEARCH.md

# Existing patterns to follow
@ClaudeMon/Models/UsageSnapshot.swift
@ClaudeMon/Services/UsageMonitor.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UsageDataPoint model</name>
  <files>ClaudeMon/Models/UsageDataPoint.swift</files>
  <action>
Create a Codable struct for storing historical usage data points:

```swift
import Foundation

/// A single point in the usage history time series.
/// Captures the essential usage metrics at a specific moment for trend visualization.
struct UsageDataPoint: Codable, Identifiable, Sendable {
    let id: UUID
    let timestamp: Date
    let primaryPercentage: Double      // 5-hour utilization (0-100)
    let sevenDayPercentage: Double?    // 7-day utilization (optional)
    let source: String                  // "oauth" or "jsonl"

    /// Create from a UsageSnapshot
    init(from snapshot: UsageSnapshot) {
        self.id = UUID()
        self.timestamp = Date()
        self.primaryPercentage = snapshot.primaryPercentage
        self.sevenDayPercentage = snapshot.sevenDayUtilization
        self.source = snapshot.source.rawValue
    }

    /// For testing/preview
    init(id: UUID = UUID(), timestamp: Date, primaryPercentage: Double, sevenDayPercentage: Double? = nil, source: String = "oauth") {
        self.id = id
        self.timestamp = timestamp
        self.primaryPercentage = primaryPercentage
        self.sevenDayPercentage = sevenDayPercentage
        self.source = source
    }
}
```

Keep it minimal -- only store what's needed for charts. Do not duplicate all UsageSnapshot fields.
  </action>
  <verify>File exists and compiles: `swift build 2>&1 | head -20`</verify>
  <done>UsageDataPoint.swift exists with Codable struct that can be initialized from UsageSnapshot</done>
</task>

<task type="auto">
  <name>Task 2: Create HistoryStore actor with JSON persistence</name>
  <files>ClaudeMon/Services/HistoryStore.swift</files>
  <action>
Create an actor-based store for thread-safe history management:

```swift
import Foundation

/// Thread-safe store for historical usage data.
/// Persists data as JSON to Application Support/ClaudeMon/usage_history.json.
/// Uses actor isolation to prevent concurrent file access issues.
actor HistoryStore {
    static let shared = HistoryStore()

    private let fileURL: URL
    private var cache: [UsageDataPoint] = []
    private let maxAgeDays: Int = 30

    init() {
        let appSupport = FileManager.default.urls(
            for: .applicationSupportDirectory,
            in: .userDomainMask
        ).first!
        let appDir = appSupport.appendingPathComponent("ClaudeMon", isDirectory: true)
        try? FileManager.default.createDirectory(at: appDir, withIntermediateDirectories: true)
        self.fileURL = appDir.appendingPathComponent("usage_history.json")
    }

    /// Load history from disk into cache. Call once at app startup.
    func load() async throws {
        guard FileManager.default.fileExists(atPath: fileURL.path) else {
            cache = []
            return
        }
        let data = try Data(contentsOf: fileURL)
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        cache = try decoder.decode([UsageDataPoint].self, from: data)
    }

    /// Append a new data point and persist.
    /// Automatically trims old entries beyond maxAgeDays.
    func append(_ point: UsageDataPoint) async throws {
        cache.append(point)
        trimOldEntries()
        try await save()
    }

    /// Get all cached data points (for chart rendering).
    func getHistory() -> [UsageDataPoint] {
        return cache
    }

    /// Get data points within a time range.
    func getHistory(since cutoff: Date) -> [UsageDataPoint] {
        return cache.filter { $0.timestamp > cutoff }
    }

    /// Clear all history (for testing or user reset).
    func clear() async throws {
        cache = []
        try await save()
    }

    // MARK: - Private

    private func trimOldEntries() {
        let cutoff = Date().addingTimeInterval(-Double(maxAgeDays) * 24 * 3600)
        cache = cache.filter { $0.timestamp > cutoff }
    }

    private func save() async throws {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        encoder.outputFormatting = .prettyPrinted
        let data = try encoder.encode(cache)
        try data.write(to: fileURL)
    }
}
```

Key design choices:
- Actor for thread safety (research pitfall #2)
- Singleton pattern consistent with OAuthClient
- 30-day trim to prevent unbounded growth (research recommendation)
- ISO8601 date encoding for human-readable JSON
  </action>
  <verify>File compiles: `swift build 2>&1 | head -20`</verify>
  <done>HistoryStore.swift exists with actor that handles load/append/getHistory operations</done>
</task>

<task type="auto">
  <name>Task 3: Wire HistoryStore to UsageMonitor</name>
  <files>ClaudeMon/Services/UsageMonitor.swift</files>
  <action>
Modify UsageMonitor to record history on each successful refresh:

1. Add a property to hold history store reference:
```swift
/// History store for recording usage over time
@ObservationIgnored
private let historyStore = HistoryStore.shared
```

2. Add a published property for history data (for chart binding):
```swift
/// Historical usage data points for trend visualization
var usageHistory: [UsageDataPoint] = []
```

3. Load history in init (after startPolling call):
```swift
// Load historical data
Task {
    do {
        try await historyStore.load()
        self.usageHistory = await historyStore.getHistory()
    } catch {
        print("[ClaudeMon] Failed to load history: \(error)")
    }
}
```

4. In refresh(), after each successful data fetch (both OAuth and JSONL success paths), add history recording:
```swift
// Record to history (after onUsageChanged/onAlertCheck calls)
let dataPoint = UsageDataPoint(from: currentUsage)
Task {
    do {
        try await historyStore.append(dataPoint)
        // Update local cache for UI
        await MainActor.run {
            self.usageHistory = await self.historyStore.getHistory()
        }
    } catch {
        print("[ClaudeMon] Failed to record history: \(error)")
    }
}
```

Note: Use a detached task or nested Task to handle the actor call without blocking the main refresh flow.

5. Add a helper to refresh history from store (for UI manual refresh if needed):
```swift
/// Reload history from store (for UI refresh)
func reloadHistory() async {
    usageHistory = await historyStore.getHistory()
}
```
  </action>
  <verify>
1. Build succeeds: `swift build 2>&1 | head -20`
2. Run app, check that ~/Library/Application Support/ClaudeMon/usage_history.json is created after first refresh
  </verify>
  <done>UsageMonitor records every successful refresh to HistoryStore, and usageHistory property is available for chart binding</done>
</task>

</tasks>

<verification>
1. `swift build` completes without errors
2. App launches without crash
3. After app runs for 1-2 refresh cycles, check file exists:
   `cat ~/Library/Application\ Support/ClaudeMon/usage_history.json | head -20`
4. File contains JSON array with UsageDataPoint entries including timestamps and percentages
5. Restart app, verify history is loaded (usageHistory.count > 0)
</verification>

<success_criteria>
- UsageDataPoint model exists and is Codable
- HistoryStore actor handles thread-safe JSON persistence
- UsageMonitor records every successful refresh
- Historical data survives app restart
- JSON file is automatically trimmed to 30 days of data
</success_criteria>

<output>
After completion, create `.planning/phases/03-usage-trends-api/03-01-SUMMARY.md`
</output>
