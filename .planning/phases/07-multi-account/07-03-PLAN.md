---
phase: 07-multi-account
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - Tokemon/Views/Settings/AccountsSettings.swift
  - Tokemon/Services/AlertManager.swift
  - Tokemon/Views/Settings/CombinedUsageView.swift
  - Tokemon/Services/HistoryStore.swift
  - Tokemon/Services/UsageMonitor.swift
  - Tokemon/TokemonApp.swift
autonomous: true

must_haves:
  truths:
    - "User can set different alert thresholds per account"
    - "User can view combined usage summary across all accounts"
    - "Per-account alerts fire based on that account's threshold"
    - "History is stored per-account for accurate per-account trends"
  artifacts:
    - path: "Tokemon/Views/Settings/CombinedUsageView.swift"
      provides: "Aggregated usage view across all accounts"
      contains: "struct CombinedUsageView"
    - path: "Tokemon/Services/AlertManager.swift"
      provides: "Per-account alert threshold support"
      contains: "checkUsage.*Account"
    - path: "Tokemon/Services/HistoryStore.swift"
      provides: "Per-account history storage"
      contains: "accountId"
  key_links:
    - from: "Tokemon/Views/Settings/CombinedUsageView.swift"
      to: "Tokemon/Services/AccountManager.swift"
      via: "Parallel fetch with TaskGroup"
      pattern: "withTaskGroup"
    - from: "Tokemon/Services/AlertManager.swift"
      to: "Account.settings.alertThreshold"
      via: "checkUsage accepts Account"
      pattern: "account\\.settings\\.alertThreshold"
---

<objective>
Add per-account alert thresholds and combined usage view. Users can customize alerts for each account and see an aggregated summary of all accounts.

Purpose: Complete the multi-account experience with per-account customization and a combined dashboard view.

Output: Per-account settings editor in AccountsSettings, modified AlertManager for per-account thresholds, CombinedUsageView for aggregated stats, per-account HistoryStore.
</objective>

<execution_context>
@/Users/richardparr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardparr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-multi-account/07-RESEARCH.md
@.planning/phases/07-multi-account/07-01-SUMMARY.md
@.planning/phases/07-multi-account/07-02-SUMMARY.md

# Files to modify
@Tokemon/Views/Settings/AccountsSettings.swift
@Tokemon/Services/AlertManager.swift
@Tokemon/Services/HistoryStore.swift
@Tokemon/Services/UsageMonitor.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add per-account settings editor to AccountsSettings</name>
  <files>
    Tokemon/Views/Settings/AccountsSettings.swift
  </files>
  <action>
Extend AccountsSettings to include per-account settings editing when an account is selected.

Add a new section after "Account Details" for per-account settings:

```swift
if let account = selectedAccount {
    // ... existing Account Details section ...

    Section("Alert Settings for \(account.displayName)") {
        // Alert threshold slider
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text("Alert Threshold")
                Spacer()
                Text("\(account.settings.alertThreshold)%")
                    .foregroundStyle(.secondary)
                    .monospacedDigit()
            }

            Slider(
                value: Binding(
                    get: { Double(account.settings.alertThreshold) },
                    set: { newValue in
                        updateThreshold(for: account, value: Int(newValue))
                    }
                ),
                in: 50...100,
                step: 5
            )

            Text("Get notified when this account reaches this usage percentage")
                .font(.caption)
                .foregroundStyle(.secondary)
        }

        // Notifications toggle
        Toggle("Enable Notifications", isOn: Binding(
            get: { account.settings.notificationsEnabled },
            set: { newValue in
                updateNotifications(for: account, enabled: newValue)
            }
        ))
    }
}
```

Add helper methods:
```swift
private func updateThreshold(for account: Account, value: Int) {
    var settings = account.settings
    settings.alertThreshold = value
    Task {
        try? await accountManager.updateAccountSettings(account, settings: settings)
        // Refresh selected account
        if let updated = accountManager.accounts.first(where: { $0.id == account.id }) {
            selectedAccount = updated
        }
    }
}

private func updateNotifications(for account: Account, enabled: Bool) {
    var settings = account.settings
    settings.notificationsEnabled = enabled
    Task {
        try? await accountManager.updateAccountSettings(account, settings: settings)
        // Refresh selected account
        if let updated = accountManager.accounts.first(where: { $0.id == account.id }) {
            selectedAccount = updated
        }
    }
}
```
  </action>
  <verify>
`swift build 2>&1 | head -20` completes without errors
  </verify>
  <done>
AccountsSettings shows per-account alert threshold slider and notifications toggle when an account is selected. Changes persist via AccountManager.
  </done>
</task>

<task type="auto">
  <name>Task 2: Modify AlertManager for per-account thresholds</name>
  <files>
    Tokemon/Services/AlertManager.swift
    Tokemon/TokemonApp.swift
  </files>
  <action>
**AlertManager.swift:**
Modify AlertManager to accept an optional Account parameter for per-account thresholds.

1. Add a reference to AccountManager for reading per-account settings:
```swift
@ObservationIgnored
private var accountManager: AccountManager?

/// Set account manager reference for per-account thresholds
func setAccountManager(_ manager: AccountManager) {
    self.accountManager = manager
}
```

2. Modify `checkUsage` to accept optional Account and use its threshold:
```swift
/// Check usage and update alert level. Called by UsageMonitor on each refresh.
/// If account is provided, uses per-account threshold. Otherwise falls back to global.
func checkUsage(_ usage: UsageSnapshot, for account: Account? = nil) {
    // Guard: only process OAuth snapshots with percentage
    guard usage.hasPercentage else { return }

    // Detect window reset
    if let resetsAt = usage.resetsAt, resetsAt != lastResetsAt {
        resetNotificationState()
        lastResetsAt = resetsAt
    }

    // Get threshold: per-account if available, otherwise global
    let threshold: Int
    let notificationsEnabled: Bool

    if let account = account {
        threshold = account.settings.alertThreshold
        notificationsEnabled = account.settings.notificationsEnabled
    } else if let activeAccount = accountManager?.activeAccount {
        threshold = activeAccount.settings.alertThreshold
        notificationsEnabled = activeAccount.settings.notificationsEnabled
    } else {
        threshold = alertThreshold  // Global fallback
        notificationsEnabled = self.notificationsEnabled
    }

    let percentage = Int(usage.primaryPercentage)
    let newLevel = alertLevel(for: percentage, threshold: threshold)

    // Update current level for UI (always)
    if newLevel != currentAlertLevel {
        currentAlertLevel = newLevel
    }

    // Only notify when crossing INTO a higher level
    if newLevel > lastNotifiedLevel && notificationsEnabled {
        lastNotifiedLevel = newLevel
        sendNotification(level: newLevel, percentage: percentage, accountName: account?.displayName)
    }
}
```

3. Update `alertLevel` to accept threshold parameter:
```swift
private func alertLevel(for percentage: Int, threshold: Int? = nil) -> AlertLevel {
    let effectiveThreshold = threshold ?? alertThreshold
    if percentage >= 100 {
        return .critical
    } else if percentage >= effectiveThreshold {
        return .warning
    }
    return .normal
}
```

4. Update `sendNotification` to optionally include account name:
```swift
private func sendNotification(level: AlertLevel, percentage: Int, accountName: String? = nil) {
    guard hasAppBundle else { return }
    guard level != .normal else { return }

    let content = UNMutableNotificationContent()
    let accountPrefix = accountName.map { "[\($0)] " } ?? ""

    switch level {
    case .warning:
        content.title = "\(accountPrefix)Claude Usage Warning"
        content.body = "You've used \(percentage)% of your 5-hour limit."
        content.sound = .default
    case .critical:
        content.title = "\(accountPrefix)Claude Usage Limit Reached"
        content.body = "You've reached your 5-hour usage limit."
        content.sound = UNNotificationSound.defaultCritical
    case .normal:
        return
    }

    // Include account in identifier to allow per-account notifications
    let accountSuffix = accountName ?? "default"
    let request = UNNotificationRequest(
        identifier: "tokemon.alert.\(level).\(accountSuffix)",
        content: content,
        trigger: nil
    )

    UNUserNotificationCenter.current().add(request) { error in
        if let error = error {
            print("[AlertManager] Notification error: \(error.localizedDescription)")
        }
    }
}
```

**TokemonApp.swift:**
Wire AlertManager to AccountManager in the menuBarExtraAccess callback:
```swift
alertManager.setAccountManager(accountManager)
```

Update the onAlertCheck callback to pass the active account:
```swift
monitor.onAlertCheck = { [alertManager, accountManager] usage in
    Task { @MainActor in
        alertManager.checkUsage(usage, for: accountManager.activeAccount)
    }
}
```
  </action>
  <verify>
`swift build 2>&1 | head -20` completes without errors
  </verify>
  <done>
AlertManager uses per-account alert thresholds. Notifications include account name when multiple accounts exist. Per-account notification settings are respected.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create CombinedUsageView and update HistoryStore for per-account</name>
  <files>
    Tokemon/Views/Settings/CombinedUsageView.swift
    Tokemon/Views/Settings/AccountsSettings.swift
    Tokemon/Services/HistoryStore.swift
    Tokemon/Services/UsageMonitor.swift
  </files>
  <action>
**CombinedUsageView.swift:**
Create new file in Views/Settings/:
```swift
import SwiftUI

/// Displays aggregated usage across all accounts.
/// Shows per-account breakdown with parallel data fetching.
struct CombinedUsageView: View {
    @Environment(AccountManager.self) private var accountManager

    @State private var accountUsages: [UUID: UsageSnapshot] = [:]
    @State private var isLoading = false
    @State private var fetchError: String?

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text("Combined Usage")
                    .font(.headline)
                Spacer()
                Button {
                    Task { await fetchAllUsage() }
                } label: {
                    Image(systemName: "arrow.clockwise")
                }
                .buttonStyle(.borderless)
                .disabled(isLoading)
            }

            if isLoading {
                HStack {
                    ProgressView()
                        .scaleEffect(0.7)
                    Text("Loading...")
                        .foregroundStyle(.secondary)
                }
            } else if let error = fetchError {
                Text(error)
                    .foregroundStyle(.red)
                    .font(.caption)
            } else if accountUsages.isEmpty {
                Text("No usage data available")
                    .foregroundStyle(.secondary)
            } else {
                // Per-account breakdown
                ForEach(accountManager.accounts) { account in
                    if let usage = accountUsages[account.id] {
                        HStack {
                            Circle()
                                .fill(Color(nsColor: GradientColors.color(for: usage.primaryPercentage)))
                                .frame(width: 8, height: 8)

                            Text(account.displayName)
                                .lineLimit(1)

                            Spacer()

                            Text("\(Int(usage.primaryPercentage))%")
                                .monospacedDigit()
                                .foregroundStyle(Color(nsColor: GradientColors.color(for: usage.primaryPercentage)))
                        }
                    }
                }

                Divider()

                // Summary row
                HStack {
                    Text(summaryLabel)
                        .fontWeight(.medium)
                    Spacer()
                    Text("\(Int(summaryValue))%")
                        .fontWeight(.medium)
                        .monospacedDigit()
                }
            }
        }
        .padding()
        .background(Color(.controlBackgroundColor))
        .clipShape(RoundedRectangle(cornerRadius: 8))
        .task {
            await fetchAllUsage()
        }
    }

    private var summaryLabel: String {
        accountUsages.count > 1 ? "Highest" : "Usage"
    }

    private var summaryValue: Double {
        // Show highest usage as the headline metric
        accountUsages.values.map { $0.primaryPercentage }.max() ?? 0
    }

    private func fetchAllUsage() async {
        isLoading = true
        fetchError = nil
        defer { isLoading = false }

        await withTaskGroup(of: (UUID, UsageSnapshot?).self) { group in
            for account in accountManager.accounts {
                group.addTask {
                    do {
                        let response = try await OAuthClient.fetchUsageWithTokenRefresh(for: account)
                        return (account.id, response.toSnapshot())
                    } catch {
                        print("[CombinedUsageView] Failed to fetch for \(account.username): \(error)")
                        return (account.id, nil)
                    }
                }
            }

            var results: [UUID: UsageSnapshot] = [:]
            for await (accountId, snapshot) in group {
                if let snapshot = snapshot {
                    results[accountId] = snapshot
                }
            }
            accountUsages = results
        }

        if accountUsages.isEmpty && !accountManager.accounts.isEmpty {
            fetchError = "Failed to load usage data"
        }
    }
}
```

**AccountsSettings.swift:**
Add CombinedUsageView at the top of the form (before the Accounts section):
```swift
var body: some View {
    Form {
        // Combined usage view (Pro feature)
        if accountManager.accounts.count > 1 {
            Section {
                CombinedUsageView()
            }
        }

        Section("Accounts") {
            // ... existing account list
        }
        // ... rest of sections
    }
    // ...
}
```

**HistoryStore.swift:**
Modify to support per-account history storage. Update the actor to use account-specific files:

```swift
actor HistoryStore {
    static let shared = HistoryStore()

    private var fileURLs: [UUID: URL] = [:]  // Account ID -> history file
    private var caches: [UUID: [UsageDataPoint]] = [:]  // Account ID -> cached points
    private let maxAgeDays: Int = 30

    /// Legacy file URL for migration (single-account)
    private var legacyFileURL: URL {
        let appSupport = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
        let appDir = appSupport.appendingPathComponent("Tokemon", isDirectory: true)
        return appDir.appendingPathComponent("usage_history.json")
    }

    private func fileURL(for accountId: UUID) -> URL {
        if let cached = fileURLs[accountId] { return cached }

        let appSupport = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
        let historyDir = appSupport.appendingPathComponent("Tokemon/history", isDirectory: true)
        try? FileManager.default.createDirectory(at: historyDir, withIntermediateDirectories: true)

        let url = historyDir.appendingPathComponent("\(accountId.uuidString).json")
        fileURLs[accountId] = url
        return url
    }

    /// Load history for a specific account
    func load(for accountId: UUID) throws {
        let url = fileURL(for: accountId)
        guard FileManager.default.fileExists(atPath: url.path) else {
            caches[accountId] = []
            return
        }
        let data = try Data(contentsOf: url)
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        caches[accountId] = try decoder.decode([UsageDataPoint].self, from: data)
    }

    /// Legacy load (single account, for migration)
    func load() throws {
        guard FileManager.default.fileExists(atPath: legacyFileURL.path) else {
            return
        }
        // Legacy data will be migrated when append is called with accountId
        let data = try Data(contentsOf: legacyFileURL)
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        let legacyData = try decoder.decode([UsageDataPoint].self, from: data)
        // Store temporarily under a nil-like key until migration
        caches[UUID()] = legacyData
    }

    /// Append a data point for a specific account
    func append(_ point: UsageDataPoint, for accountId: UUID) throws {
        var cache = caches[accountId] ?? []
        cache.append(point)
        caches[accountId] = cache
        trimOldEntries(for: accountId)
        try save(for: accountId)
    }

    /// Legacy append (uses default account behavior)
    func append(_ point: UsageDataPoint) throws {
        // This maintains backward compatibility
        // In practice, callers should use the accountId variant
        var cache = caches[UUID()] ?? []
        cache.append(point)
        caches[UUID()] = cache
        // Note: This uses legacy single-file storage
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        encoder.outputFormatting = .prettyPrinted
        let data = try encoder.encode(cache)
        try data.write(to: legacyFileURL)
    }

    /// Get history for a specific account
    func getHistory(for accountId: UUID) -> [UsageDataPoint] {
        return caches[accountId] ?? []
    }

    /// Legacy get history
    func getHistory() -> [UsageDataPoint] {
        return caches[UUID()] ?? []
    }

    /// Clear history for a specific account
    func clear(for accountId: UUID) throws {
        caches[accountId] = []
        try save(for: accountId)
    }

    /// Clear all history (legacy)
    func clear() throws {
        caches = [:]
        try? FileManager.default.removeItem(at: legacyFileURL)
    }

    private func trimOldEntries(for accountId: UUID) {
        let cutoff = Date().addingTimeInterval(-Double(maxAgeDays) * 24 * 3600)
        if var cache = caches[accountId] {
            cache = cache.filter { $0.timestamp > cutoff }
            caches[accountId] = cache
        }
    }

    private func save(for accountId: UUID) throws {
        let cache = caches[accountId] ?? []
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        encoder.outputFormatting = .prettyPrinted
        let data = try encoder.encode(cache)
        try data.write(to: fileURL(for: accountId))
    }
}
```

**UsageMonitor.swift:**
Update to pass account ID to HistoryStore when recording:
In `recordHistory`, check for active account and use per-account storage:
```swift
private func recordHistory(for usage: UsageSnapshot) async {
    let dataPoint = UsageDataPoint(from: usage)
    do {
        if let accountId = currentAccount?.id {
            try await historyStore.append(dataPoint, for: accountId)
            self.usageHistory = await historyStore.getHistory(for: accountId)
        } else {
            // Legacy single-account behavior
            try await historyStore.append(dataPoint)
            self.usageHistory = await historyStore.getHistory()
        }
    } catch {
        print("[Tokemon] Failed to record history: \(error)")
    }
}
```
  </action>
  <verify>
`swift build 2>&1 | head -20` completes without errors
  </verify>
  <done>
CombinedUsageView shows aggregated usage across all accounts with parallel fetching. HistoryStore saves per-account history files. Per-account trends are isolated.
  </done>
</task>

</tasks>

<verification>
1. `swift build` completes without errors
2. Per-account alert threshold slider works in AccountsSettings
3. CombinedUsageView appears when multiple accounts exist
4. Parallel fetch loads all account usages
5. Alerts use per-account thresholds
6. Notifications include account name
7. History is stored in per-account files
</verification>

<success_criteria>
- Per-account settings (threshold, notifications) editable in AccountsSettings
- AlertManager respects per-account thresholds
- CombinedUsageView shows all accounts with parallel fetch
- Shows highest usage as headline metric
- HistoryStore uses per-account files in Tokemon/history/
- Notifications include account name when relevant
</success_criteria>

<output>
After completion, create `.planning/phases/07-multi-account/07-03-SUMMARY.md`
</output>
