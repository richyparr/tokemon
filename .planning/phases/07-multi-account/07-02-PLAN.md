---
phase: 07-multi-account
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - ClaudeMon/ClaudeMonApp.swift
  - ClaudeMon/Views/MenuBar/PopoverContentView.swift
  - ClaudeMon/Views/MenuBar/AccountSwitcherView.swift
  - ClaudeMon/Views/Settings/AccountsSettings.swift
  - ClaudeMon/Views/Settings/SettingsView.swift
  - ClaudeMon/Services/SettingsWindowController.swift
  - ClaudeMon/Services/UsageMonitor.swift
  - ClaudeMon/Services/OAuthClient.swift
  - ClaudeMon/Services/AccountManager.swift
autonomous: true

must_haves:
  truths:
    - "User can see their active account name in the popover header"
    - "User can switch between accounts from the popover menu"
    - "User can add, rename, and remove accounts in Settings"
    - "Usage data refreshes automatically when switching accounts"
    - "User can add a second Claude account via OAuth (detected from Claude Code keychain)"
  artifacts:
    - path: "ClaudeMon/Views/MenuBar/AccountSwitcherView.swift"
      provides: "Account picker dropdown in popover header"
      contains: "struct AccountSwitcherView"
    - path: "ClaudeMon/Views/Settings/AccountsSettings.swift"
      provides: "Accounts management settings tab"
      contains: "struct AccountsSettings"
    - path: "ClaudeMon/Views/Settings/SettingsView.swift"
      provides: "Updated settings with Accounts tab"
      contains: "AccountsSettings()"
    - path: "ClaudeMon/Services/AccountManager.swift"
      provides: "checkForNewAccounts implementation"
      contains: "func checkForNewAccounts"
  key_links:
    - from: "ClaudeMon/ClaudeMonApp.swift"
      to: "ClaudeMon/Services/AccountManager.swift"
      via: "@State private var accountManager"
      pattern: "accountManager"
    - from: "ClaudeMon/Views/MenuBar/AccountSwitcherView.swift"
      to: "ClaudeMon/Services/AccountManager.swift"
      via: "@Environment(AccountManager.self)"
      pattern: "Environment\\(AccountManager"
    - from: "ClaudeMon/Services/UsageMonitor.swift"
      to: "Account context"
      via: "refresh(for account:)"
      pattern: "refresh\\(for account:"
    - from: "ClaudeMon/Services/AccountManager.swift"
      to: "KeychainAccess"
      via: "allKeys() for keychain scanning"
      pattern: "allKeys\\(\\)"
---

<objective>
Build the account switcher UI and integrate AccountManager throughout the app. Users can switch accounts from the popover and manage accounts in Settings.

Purpose: Enable users to switch between multiple Claude accounts and see usage data for their selected account.

Output: AccountSwitcherView in popover header, AccountsSettings tab, app-wide AccountManager integration, account-aware UsageMonitor refresh, and keychain scanning for new account detection.
</objective>

<execution_context>
@/Users/richardparr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardparr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-multi-account/07-RESEARCH.md
@.planning/phases/07-multi-account/07-01-SUMMARY.md

# Files to modify
@ClaudeMon/ClaudeMonApp.swift
@ClaudeMon/Views/MenuBar/PopoverContentView.swift
@ClaudeMon/Views/Settings/SettingsView.swift
@ClaudeMon/Services/SettingsWindowController.swift
@ClaudeMon/Services/UsageMonitor.swift
@ClaudeMon/Services/OAuthClient.swift
@ClaudeMon/Services/AccountManager.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate AccountManager into app and wire UsageMonitor</name>
  <files>
    ClaudeMon/ClaudeMonApp.swift
    ClaudeMon/Services/UsageMonitor.swift
    ClaudeMon/Services/OAuthClient.swift
  </files>
  <action>
**ClaudeMonApp.swift:**
1. Add `@State private var accountManager = AccountManager()` alongside other managers
2. Pass to all views via `.environment(accountManager)`:
   - PopoverContentView
   - SettingsView
   - Settings scene
3. Pass to SettingsWindowController: `SettingsWindowController.shared.setAccountManager(accountManager)`
4. Wire accountManager.onActiveAccountChanged to trigger UsageMonitor refresh:
```swift
accountManager.onActiveAccountChanged = { [monitor] account in
    Task { @MainActor in
        await monitor.refresh()
    }
}
```

**UsageMonitor.swift:**
1. Add optional `currentAccount: Account?` property (set by account change callback)
2. Modify `refresh()` to use account-specific token if currentAccount is set:
```swift
// In refresh(), replace the OAuthClient call:
if let account = currentAccount {
    let response = try await OAuthClient.fetchUsageWithTokenRefresh(for: account)
    // ... rest of success handling
} else {
    // Fallback to original behavior for backward compatibility
    let response = try await OAuthClient.fetchUsageWithTokenRefresh()
    // ... rest of success handling
}
```

**OAuthClient.swift:**
Add account-aware fetch methods:
```swift
/// Fetch usage for a specific account
static func fetchUsage(for account: Account) async throws -> OAuthUsageResponse {
    let accessToken = try TokenManager.getAccessToken(for: account.username)
    return try await fetchUsage(accessToken: accessToken)
}

/// Fetch usage with token refresh for a specific account
static func fetchUsageWithTokenRefresh(for account: Account) async throws -> OAuthUsageResponse {
    do {
        let accessToken = try TokenManager.getAccessToken(for: account.username)
        return try await fetchUsage(accessToken: accessToken)
    } catch TokenManager.TokenError.expired {
        let refreshedToken = try await performTokenRefresh(for: account.username)
        return try await fetchUsage(accessToken: refreshedToken)
    }
}

private static func performTokenRefresh(for username: String) async throws -> String {
    let refreshToken = try TokenManager.getRefreshToken(for: username)
    let tokenResponse = try await TokenManager.refreshAccessToken(refreshToken: refreshToken)
    try TokenManager.updateKeychainCredentials(response: tokenResponse, for: username)
    return tokenResponse.accessToken
}
```
  </action>
  <verify>
`swift build 2>&1 | head -20` completes without errors
  </verify>
  <done>
AccountManager is initialized in ClaudeMonApp, passed via environment, and account changes trigger UsageMonitor refresh with account-specific credentials.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AccountSwitcherView for popover</name>
  <files>
    ClaudeMon/Views/MenuBar/AccountSwitcherView.swift
    ClaudeMon/Views/MenuBar/PopoverContentView.swift
  </files>
  <action>
**AccountSwitcherView.swift:**
Create new file in Views/MenuBar/:
```swift
import SwiftUI

/// Compact account picker displayed in popover header.
/// Only visible for Pro users with multiple accounts.
struct AccountSwitcherView: View {
    @Environment(AccountManager.self) private var accountManager
    @Environment(FeatureAccessManager.self) private var featureAccess

    var body: some View {
        // Only show if Pro and has accounts
        if featureAccess.canAccess(.multiAccount) && !accountManager.accounts.isEmpty {
            Menu {
                ForEach(accountManager.accounts) { account in
                    Button {
                        Task {
                            try? await accountManager.setActiveAccount(account)
                        }
                    } label: {
                        HStack {
                            Text(account.displayName)
                            if account.id == accountManager.activeAccount?.id {
                                Spacer()
                                Image(systemName: "checkmark")
                            }
                        }
                    }
                }

                if accountManager.accounts.count > 1 {
                    Divider()
                }

                Button("Manage Accounts...") {
                    SettingsWindowController.shared.showSettings(tab: .accounts)
                }
            } label: {
                HStack(spacing: 4) {
                    Image(systemName: "person.crop.circle")
                        .font(.system(size: 14))
                    Text(accountManager.activeAccount?.displayName ?? "No Account")
                        .lineLimit(1)
                        .truncationMode(.tail)
                    Image(systemName: "chevron.down")
                        .font(.caption2)
                }
                .foregroundStyle(.secondary)
            }
            .menuStyle(.borderlessButton)
            .fixedSize()
        }
    }
}
```

**PopoverContentView.swift:**
1. Add `@Environment(AccountManager.self) private var accountManager` to environment properties
2. Add AccountSwitcherView at the top of the VStack, before UsageHeaderView:
```swift
var body: some View {
    popoverContent
        .preferredColorScheme(themeColors.colorSchemeOverride)
}

private var popoverContent: some View {
    VStack(spacing: 16) {
        // Account switcher (Pro only, multiple accounts)
        HStack {
            AccountSwitcherView()
            Spacer()
        }

        // Big percentage number (dominant, first thing user sees)
        UsageHeaderView(usage: monitor.currentUsage, alertLevel: alertManager.currentAlertLevel)
        // ... rest unchanged
    }
}
```

Only show the account switcher row if there's content (the view handles its own visibility).
  </action>
  <verify>
`swift build 2>&1 | head -20` completes without errors
  </verify>
  <done>
AccountSwitcherView appears in popover header when Pro with multiple accounts. Selecting an account triggers setActiveAccount which refreshes usage.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create AccountsSettings tab with checkForNewAccounts implementation</name>
  <files>
    ClaudeMon/Views/Settings/AccountsSettings.swift
    ClaudeMon/Views/Settings/SettingsView.swift
    ClaudeMon/Services/SettingsWindowController.swift
    ClaudeMon/Services/AccountManager.swift
  </files>
  <action>
**AccountManager.swift:**
Add the `checkForNewAccounts()` method that scans Claude Code's keychain for new usernames:

```swift
/// Scan Claude Code's keychain for accounts not yet registered in ClaudeMon.
/// Users run `claude login` externally, then ClaudeMon detects and imports the new credentials.
/// Returns array of newly added accounts.
@discardableResult
func checkForNewAccounts() async throws -> [Account] {
    let claudeKeychain = Keychain(service: Constants.keychainService)

    // Get all keys (usernames) from Claude Code's keychain
    let allKeys = claudeKeychain.allKeys()

    // Find keys not already in our accounts list
    let existingUsernames = Set(accounts.map { $0.username })
    let newUsernames = allKeys.filter { !existingUsernames.contains($0) }

    var newAccounts: [Account] = []

    for username in newUsernames {
        // Verify credentials are valid (readable) before adding
        do {
            _ = try TokenManager.getCredentials(username: username)
            let account = try await addAccount(username: username)
            newAccounts.append(account)
            print("[AccountManager] Discovered new account: \(username)")
        } catch {
            // Skip invalid/unreadable credentials
            print("[AccountManager] Skipping \(username): \(error.localizedDescription)")
        }
    }

    return newAccounts
}
```

**AccountsSettings.swift:**
Create new file in Views/Settings/:
```swift
import SwiftUI

/// Settings tab for managing Claude accounts.
/// Allows adding, renaming, and removing accounts.
struct AccountsSettings: View {
    @Environment(AccountManager.self) private var accountManager
    @Environment(FeatureAccessManager.self) private var featureAccess

    @State private var selectedAccount: Account?
    @State private var showingRemoveConfirmation = false
    @State private var editingDisplayName = ""
    @State private var isEditingName = false
    @State private var isCheckingForAccounts = false
    @State private var checkResultMessage: String?

    var body: some View {
        Form {
            Section("Accounts") {
                if accountManager.accounts.isEmpty {
                    Text("No accounts configured")
                        .foregroundStyle(.secondary)
                        .italic()
                } else {
                    ForEach(accountManager.accounts) { account in
                        accountRow(account)
                    }
                }
            }

            if let account = selectedAccount {
                Section("Account Details") {
                    // Display name editor
                    HStack {
                        Text("Display Name")
                        Spacer()
                        if isEditingName {
                            TextField("Name", text: $editingDisplayName)
                                .textFieldStyle(.roundedBorder)
                                .frame(width: 150)
                                .onSubmit {
                                    saveDisplayName(for: account)
                                }
                            Button("Save") {
                                saveDisplayName(for: account)
                            }
                            .buttonStyle(.borderedProminent)
                        } else {
                            Text(account.displayName)
                                .foregroundStyle(.secondary)
                            Button("Edit") {
                                editingDisplayName = account.displayName
                                isEditingName = true
                            }
                            .buttonStyle(.borderless)
                        }
                    }

                    // Username (read-only)
                    HStack {
                        Text("Username")
                        Spacer()
                        Text(account.username)
                            .foregroundStyle(.secondary)
                    }

                    // Created date
                    HStack {
                        Text("Added")
                        Spacer()
                        Text(account.createdAt, style: .date)
                            .foregroundStyle(.secondary)
                    }
                }

                Section {
                    Button("Remove Account", role: .destructive) {
                        showingRemoveConfirmation = true
                    }
                    .disabled(accountManager.accounts.count == 1)
                }
            }

            Section {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Adding Accounts")
                        .font(.headline)
                    Text("To add another Claude account, run `claude login` in Terminal with different credentials, then click the button below to detect the new account.")
                        .font(.caption)
                        .foregroundStyle(.secondary)

                    HStack {
                        Button {
                            Task {
                                await checkForNewAccounts()
                            }
                        } label: {
                            HStack(spacing: 6) {
                                if isCheckingForAccounts {
                                    ProgressView()
                                        .scaleEffect(0.7)
                                }
                                Text("Check for New Accounts")
                            }
                        }
                        .disabled(isCheckingForAccounts)

                        if let message = checkResultMessage {
                            Text(message)
                                .font(.caption)
                                .foregroundStyle(message.contains("Found") ? .green : .secondary)
                        }
                    }
                }
            }
        }
        .formStyle(.grouped)
        .confirmationDialog(
            "Remove Account?",
            isPresented: $showingRemoveConfirmation,
            titleVisibility: .visible
        ) {
            Button("Remove", role: .destructive) {
                if let account = selectedAccount {
                    Task {
                        try? await accountManager.removeAccount(account)
                        selectedAccount = nil
                    }
                }
            }
            Button("Cancel", role: .cancel) {}
        } message: {
            Text("This will remove the account from ClaudeMon. Your Claude credentials will not be affected.")
        }
        .proGated(feature: .multiAccount)
    }

    @ViewBuilder
    private func accountRow(_ account: Account) -> some View {
        HStack {
            VStack(alignment: .leading, spacing: 2) {
                Text(account.displayName)
                    .fontWeight(.medium)
                if account.displayName != account.username {
                    Text(account.username)
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
            }

            Spacer()

            if account.id == accountManager.activeAccount?.id {
                Text("Active")
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 2)
                    .background(Color.green.opacity(0.2))
                    .foregroundStyle(.green)
                    .clipShape(Capsule())
            } else {
                Button("Switch") {
                    Task { try? await accountManager.setActiveAccount(account) }
                }
                .buttonStyle(.borderless)
            }
        }
        .contentShape(Rectangle())
        .onTapGesture {
            selectedAccount = account
            isEditingName = false
        }
        .background(selectedAccount?.id == account.id ? Color.accentColor.opacity(0.1) : Color.clear)
    }

    private func saveDisplayName(for account: Account) {
        let trimmed = editingDisplayName.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return }

        Task {
            try? await accountManager.updateDisplayName(account, displayName: trimmed)
            isEditingName = false
            // Update selectedAccount to reflect change
            if let updated = accountManager.accounts.first(where: { $0.id == account.id }) {
                selectedAccount = updated
            }
        }
    }

    private func checkForNewAccounts() async {
        isCheckingForAccounts = true
        checkResultMessage = nil
        defer { isCheckingForAccounts = false }

        do {
            let newAccounts = try await accountManager.checkForNewAccounts()
            if newAccounts.isEmpty {
                checkResultMessage = "No new accounts found"
            } else if newAccounts.count == 1 {
                checkResultMessage = "Found 1 new account"
            } else {
                checkResultMessage = "Found \(newAccounts.count) new accounts"
            }
        } catch {
            checkResultMessage = "Error: \(error.localizedDescription)"
        }

        // Clear message after 5 seconds
        Task {
            try? await Task.sleep(for: .seconds(5))
            checkResultMessage = nil
        }
    }
}
```

**SettingsView.swift:**
Add Accounts tab between Alerts and License:
```swift
TabView {
    // ... existing tabs (General, Data Sources, Appearance, Alerts)

    AccountsSettings()
        .environment(accountManager)  // Add accountManager environment
        .environment(featureAccess)
        .tabItem {
            Label("Accounts", systemImage: "person.2.fill")
        }

    LicenseSettings()
    // ... rest
}
```

Also add `@Environment(AccountManager.self) private var accountManager` to SettingsView.

**SettingsWindowController.swift:**
1. Add `private var accountManager: AccountManager?`
2. Add setter: `func setAccountManager(_ manager: AccountManager) { self.accountManager = manager }`
3. Add accountManager to the environment in showSettings():
```swift
let settingsView = SettingsView()
    .environment(monitor)
    .environment(alertManager)
    .environment(themeManager)
    .environment(licenseManager)
    .environment(featureAccess)
    .environment(accountManager)  // Add this
```
4. Add optional `tab` parameter to showSettings for deep linking:
```swift
enum SettingsTab {
    case general, dataSources, appearance, alerts, accounts, license, adminAPI
}

func showSettings(tab: SettingsTab? = nil) {
    // ... existing window creation
    // Tab selection would require storing a binding - for now, just open the window
}
```
  </action>
  <verify>
`swift build 2>&1 | head -20` completes without errors
  </verify>
  <done>
AccountsSettings tab appears in Settings (Pro-gated). Users can see accounts, switch active, rename, and remove. checkForNewAccounts() scans Claude Code's keychain using allKeys() and imports any new accounts found. SettingsWindowController passes AccountManager to settings views.
  </done>
</task>

</tasks>

<verification>
1. `swift build` completes without errors
2. AccountManager is available throughout the app via environment
3. AccountSwitcherView appears in popover for Pro users with accounts
4. AccountsSettings tab visible in Settings (gated by Pro)
5. Switching accounts triggers usage refresh
6. Account management (rename, remove) works in settings
7. checkForNewAccounts() scans keychain and imports new accounts
</verification>

<success_criteria>
- AccountManager integrated into ClaudeMonApp with environment
- AccountSwitcherView shows in popover header when Pro + multiple accounts
- AccountsSettings tab in SettingsView for account management
- Selecting a different account refreshes usage data
- Account display names can be edited in settings
- Accounts can be removed (except the last one)
- User can add a second Claude account via OAuth: run `claude login` externally, click "Check for New Accounts", ClaudeMon scans keychain using allKeys() and imports new accounts
</success_criteria>

<output>
After completion, create `.planning/phases/07-multi-account/07-02-SUMMARY.md`
</output>
