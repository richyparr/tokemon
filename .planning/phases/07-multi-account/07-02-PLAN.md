---
phase: 07-multi-account
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - ClaudeMon/ClaudeMonApp.swift
  - ClaudeMon/Views/MenuBar/PopoverContentView.swift
  - ClaudeMon/Views/MenuBar/AccountSwitcherView.swift
  - ClaudeMon/Views/Settings/AccountsSettings.swift
  - ClaudeMon/Views/Settings/SettingsView.swift
  - ClaudeMon/Services/SettingsWindowController.swift
  - ClaudeMon/Services/UsageMonitor.swift
  - ClaudeMon/Services/OAuthClient.swift
autonomous: true

must_haves:
  truths:
    - "User can see their active account name in the popover header"
    - "User can switch between accounts from the popover menu"
    - "User can add, rename, and remove accounts in Settings"
    - "Usage data refreshes automatically when switching accounts"
  artifacts:
    - path: "ClaudeMon/Views/MenuBar/AccountSwitcherView.swift"
      provides: "Account picker dropdown in popover header"
      contains: "struct AccountSwitcherView"
    - path: "ClaudeMon/Views/Settings/AccountsSettings.swift"
      provides: "Accounts management settings tab"
      contains: "struct AccountsSettings"
    - path: "ClaudeMon/Views/Settings/SettingsView.swift"
      provides: "Updated settings with Accounts tab"
      contains: "AccountsSettings()"
  key_links:
    - from: "ClaudeMon/ClaudeMonApp.swift"
      to: "ClaudeMon/Services/AccountManager.swift"
      via: "@State private var accountManager"
      pattern: "accountManager"
    - from: "ClaudeMon/Views/MenuBar/AccountSwitcherView.swift"
      to: "ClaudeMon/Services/AccountManager.swift"
      via: "@Environment(AccountManager.self)"
      pattern: "Environment\\(AccountManager"
    - from: "ClaudeMon/Services/UsageMonitor.swift"
      to: "Account context"
      via: "refresh(for account:)"
      pattern: "refresh\\(for account:"
---

<objective>
Build the account switcher UI and integrate AccountManager throughout the app. Users can switch accounts from the popover and manage accounts in Settings.

Purpose: Enable users to switch between multiple Claude accounts and see usage data for their selected account.

Output: AccountSwitcherView in popover header, AccountsSettings tab, app-wide AccountManager integration, and account-aware UsageMonitor refresh.
</objective>

<execution_context>
@/Users/richardparr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardparr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-multi-account/07-RESEARCH.md
@.planning/phases/07-multi-account/07-01-SUMMARY.md

# Files to modify
@ClaudeMon/ClaudeMonApp.swift
@ClaudeMon/Views/MenuBar/PopoverContentView.swift
@ClaudeMon/Views/Settings/SettingsView.swift
@ClaudeMon/Services/SettingsWindowController.swift
@ClaudeMon/Services/UsageMonitor.swift
@ClaudeMon/Services/OAuthClient.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate AccountManager into app and wire UsageMonitor</name>
  <files>
    ClaudeMon/ClaudeMonApp.swift
    ClaudeMon/Services/UsageMonitor.swift
    ClaudeMon/Services/OAuthClient.swift
  </files>
  <action>
**ClaudeMonApp.swift:**
1. Add `@State private var accountManager = AccountManager()` alongside other managers
2. Pass to all views via `.environment(accountManager)`:
   - PopoverContentView
   - SettingsView
   - Settings scene
3. Pass to SettingsWindowController: `SettingsWindowController.shared.setAccountManager(accountManager)`
4. Wire accountManager.onActiveAccountChanged to trigger UsageMonitor refresh:
```swift
accountManager.onActiveAccountChanged = { [monitor] account in
    Task { @MainActor in
        await monitor.refresh()
    }
}
```

**UsageMonitor.swift:**
1. Add optional `currentAccount: Account?` property (set by account change callback)
2. Modify `refresh()` to use account-specific token if currentAccount is set:
```swift
// In refresh(), replace the OAuthClient call:
if let account = currentAccount {
    let response = try await OAuthClient.fetchUsageWithTokenRefresh(for: account)
    // ... rest of success handling
} else {
    // Fallback to original behavior for backward compatibility
    let response = try await OAuthClient.fetchUsageWithTokenRefresh()
    // ... rest of success handling
}
```

**OAuthClient.swift:**
Add account-aware fetch methods:
```swift
/// Fetch usage for a specific account
static func fetchUsage(for account: Account) async throws -> OAuthUsageResponse {
    let accessToken = try TokenManager.getAccessToken(for: account.username)
    return try await fetchUsage(accessToken: accessToken)
}

/// Fetch usage with token refresh for a specific account
static func fetchUsageWithTokenRefresh(for account: Account) async throws -> OAuthUsageResponse {
    do {
        let accessToken = try TokenManager.getAccessToken(for: account.username)
        return try await fetchUsage(accessToken: accessToken)
    } catch TokenManager.TokenError.expired {
        let refreshedToken = try await performTokenRefresh(for: account.username)
        return try await fetchUsage(accessToken: refreshedToken)
    }
}

private static func performTokenRefresh(for username: String) async throws -> String {
    let refreshToken = try TokenManager.getRefreshToken(for: username)
    let tokenResponse = try await TokenManager.refreshAccessToken(refreshToken: refreshToken)
    try TokenManager.updateKeychainCredentials(response: tokenResponse, for: username)
    return tokenResponse.accessToken
}
```
  </action>
  <verify>
`swift build 2>&1 | head -20` completes without errors
  </verify>
  <done>
AccountManager is initialized in ClaudeMonApp, passed via environment, and account changes trigger UsageMonitor refresh with account-specific credentials.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AccountSwitcherView for popover</name>
  <files>
    ClaudeMon/Views/MenuBar/AccountSwitcherView.swift
    ClaudeMon/Views/MenuBar/PopoverContentView.swift
  </files>
  <action>
**AccountSwitcherView.swift:**
Create new file in Views/MenuBar/:
```swift
import SwiftUI

/// Compact account picker displayed in popover header.
/// Only visible for Pro users with multiple accounts.
struct AccountSwitcherView: View {
    @Environment(AccountManager.self) private var accountManager
    @Environment(FeatureAccessManager.self) private var featureAccess

    var body: some View {
        // Only show if Pro and has accounts
        if featureAccess.canAccess(.multiAccount) && !accountManager.accounts.isEmpty {
            Menu {
                ForEach(accountManager.accounts) { account in
                    Button {
                        Task {
                            try? await accountManager.setActiveAccount(account)
                        }
                    } label: {
                        HStack {
                            Text(account.displayName)
                            if account.id == accountManager.activeAccount?.id {
                                Spacer()
                                Image(systemName: "checkmark")
                            }
                        }
                    }
                }

                if accountManager.accounts.count > 1 {
                    Divider()
                }

                Button("Manage Accounts...") {
                    SettingsWindowController.shared.showSettings(tab: .accounts)
                }
            } label: {
                HStack(spacing: 4) {
                    Image(systemName: "person.crop.circle")
                        .font(.system(size: 14))
                    Text(accountManager.activeAccount?.displayName ?? "No Account")
                        .lineLimit(1)
                        .truncationMode(.tail)
                    Image(systemName: "chevron.down")
                        .font(.caption2)
                }
                .foregroundStyle(.secondary)
            }
            .menuStyle(.borderlessButton)
            .fixedSize()
        }
    }
}
```

**PopoverContentView.swift:**
1. Add `@Environment(AccountManager.self) private var accountManager` to environment properties
2. Add AccountSwitcherView at the top of the VStack, before UsageHeaderView:
```swift
var body: some View {
    popoverContent
        .preferredColorScheme(themeColors.colorSchemeOverride)
}

private var popoverContent: some View {
    VStack(spacing: 16) {
        // Account switcher (Pro only, multiple accounts)
        HStack {
            AccountSwitcherView()
            Spacer()
        }

        // Big percentage number (dominant, first thing user sees)
        UsageHeaderView(usage: monitor.currentUsage, alertLevel: alertManager.currentAlertLevel)
        // ... rest unchanged
    }
}
```

Only show the account switcher row if there's content (the view handles its own visibility).
  </action>
  <verify>
`swift build 2>&1 | head -20` completes without errors
  </verify>
  <done>
AccountSwitcherView appears in popover header when Pro with multiple accounts. Selecting an account triggers setActiveAccount which refreshes usage.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create AccountsSettings tab and update SettingsView</name>
  <files>
    ClaudeMon/Views/Settings/AccountsSettings.swift
    ClaudeMon/Views/Settings/SettingsView.swift
    ClaudeMon/Services/SettingsWindowController.swift
  </files>
  <action>
**AccountsSettings.swift:**
Create new file in Views/Settings/:
```swift
import SwiftUI

/// Settings tab for managing Claude accounts.
/// Allows adding, renaming, and removing accounts.
struct AccountsSettings: View {
    @Environment(AccountManager.self) private var accountManager
    @Environment(FeatureAccessManager.self) private var featureAccess

    @State private var selectedAccount: Account?
    @State private var showingRemoveConfirmation = false
    @State private var editingDisplayName = ""
    @State private var isEditingName = false

    var body: some View {
        Form {
            Section("Accounts") {
                if accountManager.accounts.isEmpty {
                    Text("No accounts configured")
                        .foregroundStyle(.secondary)
                        .italic()
                } else {
                    ForEach(accountManager.accounts) { account in
                        accountRow(account)
                    }
                }
            }

            if let account = selectedAccount {
                Section("Account Details") {
                    // Display name editor
                    HStack {
                        Text("Display Name")
                        Spacer()
                        if isEditingName {
                            TextField("Name", text: $editingDisplayName)
                                .textFieldStyle(.roundedBorder)
                                .frame(width: 150)
                                .onSubmit {
                                    saveDisplayName(for: account)
                                }
                            Button("Save") {
                                saveDisplayName(for: account)
                            }
                            .buttonStyle(.borderedProminent)
                        } else {
                            Text(account.displayName)
                                .foregroundStyle(.secondary)
                            Button("Edit") {
                                editingDisplayName = account.displayName
                                isEditingName = true
                            }
                            .buttonStyle(.borderless)
                        }
                    }

                    // Username (read-only)
                    HStack {
                        Text("Username")
                        Spacer()
                        Text(account.username)
                            .foregroundStyle(.secondary)
                    }

                    // Created date
                    HStack {
                        Text("Added")
                        Spacer()
                        Text(account.createdAt, style: .date)
                            .foregroundStyle(.secondary)
                    }
                }

                Section {
                    Button("Remove Account", role: .destructive) {
                        showingRemoveConfirmation = true
                    }
                    .disabled(accountManager.accounts.count == 1)
                }
            }

            Section {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Adding Accounts")
                        .font(.headline)
                    Text("To add another Claude account, run `claude login` in Terminal with different credentials. ClaudeMon will detect the new account automatically.")
                        .font(.caption)
                        .foregroundStyle(.secondary)

                    Button("Check for New Accounts") {
                        Task {
                            await checkForNewAccounts()
                        }
                    }
                }
            }
        }
        .formStyle(.grouped)
        .confirmationDialog(
            "Remove Account?",
            isPresented: $showingRemoveConfirmation,
            titleVisibility: .visible
        ) {
            Button("Remove", role: .destructive) {
                if let account = selectedAccount {
                    Task {
                        try? await accountManager.removeAccount(account)
                        selectedAccount = nil
                    }
                }
            }
            Button("Cancel", role: .cancel) {}
        } message: {
            Text("This will remove the account from ClaudeMon. Your Claude credentials will not be affected.")
        }
        .proGated(feature: .multiAccount)
    }

    @ViewBuilder
    private func accountRow(_ account: Account) -> some View {
        HStack {
            VStack(alignment: .leading, spacing: 2) {
                Text(account.displayName)
                    .fontWeight(.medium)
                if account.displayName != account.username {
                    Text(account.username)
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
            }

            Spacer()

            if account.id == accountManager.activeAccount?.id {
                Text("Active")
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 2)
                    .background(Color.green.opacity(0.2))
                    .foregroundStyle(.green)
                    .clipShape(Capsule())
            } else {
                Button("Switch") {
                    Task { try? await accountManager.setActiveAccount(account) }
                }
                .buttonStyle(.borderless)
            }
        }
        .contentShape(Rectangle())
        .onTapGesture {
            selectedAccount = account
            isEditingName = false
        }
        .background(selectedAccount?.id == account.id ? Color.accentColor.opacity(0.1) : Color.clear)
    }

    private func saveDisplayName(for account: Account) {
        let trimmed = editingDisplayName.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return }

        Task {
            try? await accountManager.updateDisplayName(account, displayName: trimmed)
            isEditingName = false
            // Update selectedAccount to reflect change
            if let updated = accountManager.accounts.first(where: { $0.id == account.id }) {
                selectedAccount = updated
            }
        }
    }

    private func checkForNewAccounts() async {
        // Check Claude Code's keychain for new usernames
        // This is a simplified check - in practice, users run `claude login` for new accounts
        // and we detect on next app launch via AccountManager's migration logic
    }
}
```

**SettingsView.swift:**
Add Accounts tab between Alerts and License:
```swift
TabView {
    // ... existing tabs (General, Data Sources, Appearance, Alerts)

    AccountsSettings()
        .environment(accountManager)  // Add accountManager environment
        .environment(featureAccess)
        .tabItem {
            Label("Accounts", systemImage: "person.2.fill")
        }

    LicenseSettings()
    // ... rest
}
```

Also add `@Environment(AccountManager.self) private var accountManager` to SettingsView.

**SettingsWindowController.swift:**
1. Add `private var accountManager: AccountManager?`
2. Add setter: `func setAccountManager(_ manager: AccountManager) { self.accountManager = manager }`
3. Add accountManager to the environment in showSettings():
```swift
let settingsView = SettingsView()
    .environment(monitor)
    .environment(alertManager)
    .environment(themeManager)
    .environment(licenseManager)
    .environment(featureAccess)
    .environment(accountManager)  // Add this
```
4. Add optional `tab` parameter to showSettings for deep linking:
```swift
enum SettingsTab {
    case general, dataSources, appearance, alerts, accounts, license, adminAPI
}

func showSettings(tab: SettingsTab? = nil) {
    // ... existing window creation
    // Tab selection would require storing a binding - for now, just open the window
}
```
  </action>
  <verify>
`swift build 2>&1 | head -20` completes without errors
  </verify>
  <done>
AccountsSettings tab appears in Settings (Pro-gated). Users can see accounts, switch active, rename, and remove. SettingsWindowController passes AccountManager to settings views.
  </done>
</task>

</tasks>

<verification>
1. `swift build` completes without errors
2. AccountManager is available throughout the app via environment
3. AccountSwitcherView appears in popover for Pro users with accounts
4. AccountsSettings tab visible in Settings (gated by Pro)
5. Switching accounts triggers usage refresh
6. Account management (rename, remove) works in settings
</verification>

<success_criteria>
- AccountManager integrated into ClaudeMonApp with environment
- AccountSwitcherView shows in popover header when Pro + multiple accounts
- AccountsSettings tab in SettingsView for account management
- Selecting a different account refreshes usage data
- Account display names can be edited in settings
- Accounts can be removed (except the last one)
</success_criteria>

<output>
After completion, create `.planning/phases/07-multi-account/07-02-SUMMARY.md`
</output>
