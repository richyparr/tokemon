---
phase: 07-multi-account
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Tokemon/Models/Account.swift
  - Tokemon/Models/AccountSettings.swift
  - Tokemon/Services/AccountManager.swift
  - Tokemon/Services/TokenManager.swift
  - Tokemon/Utilities/Constants.swift
autonomous: true

must_haves:
  truths:
    - "App can store metadata for multiple Claude accounts"
    - "App can read credentials for any stored account by username"
    - "App tracks which account is currently active"
    - "Existing single-account users are migrated to multi-account on first launch"
  artifacts:
    - path: "Tokemon/Models/Account.swift"
      provides: "Account struct with ID, username, displayName, settings"
      contains: "struct Account"
    - path: "Tokemon/Models/AccountSettings.swift"
      provides: "Per-account preferences (alertThreshold, notificationsEnabled)"
      contains: "struct AccountSettings"
    - path: "Tokemon/Services/AccountManager.swift"
      provides: "Central account coordination service"
      exports: ["AccountManager", "accounts", "activeAccount"]
    - path: "Tokemon/Utilities/Constants.swift"
      provides: "accountsKeychainService constant"
      contains: "accountsKeychainService"
  key_links:
    - from: "Tokemon/Services/AccountManager.swift"
      to: "KeychainAccess"
      via: "Keychain(service: Constants.accountsKeychainService)"
      pattern: "accountsKeychainService"
    - from: "Tokemon/Services/TokenManager.swift"
      to: "KeychainAccess"
      via: "getCredentials(username:) overload"
      pattern: "func getCredentials\\(username:"
---

<objective>
Create the core multi-account infrastructure: Account model, AccountSettings model, and AccountManager service that coordinates multiple Claude credentials.

Purpose: Enable storage and management of multiple Claude accounts with per-account settings, laying the foundation for account switching and combined usage views.

Output: Account.swift, AccountSettings.swift, AccountManager.swift with working account CRUD, plus TokenManager extensions for account-specific credential access.
</objective>

<execution_context>
@/Users/richardparr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardparr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-multi-account/07-RESEARCH.md

# Existing services to extend/integrate with
@Tokemon/Services/TokenManager.swift
@Tokemon/Services/LicenseManager.swift
@Tokemon/Utilities/Constants.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Account and AccountSettings models</name>
  <files>
    Tokemon/Models/Account.swift
    Tokemon/Models/AccountSettings.swift
  </files>
  <action>
Create two model files:

**Account.swift:**
- `struct Account: Identifiable, Codable, Sendable`
- Properties: `id: UUID`, `displayName: String`, `username: String`, `createdAt: Date`, `settings: AccountSettings`
- Computed `hasValidCredentials: Bool` (default true, set false when OAuth refresh fails)
- Initializer with defaults: `init(id: UUID = UUID(), displayName: String? = nil, username: String)` where displayName defaults to username

**AccountSettings.swift:**
- `struct AccountSettings: Codable, Sendable`
- Properties: `alertThreshold: Int = 80`, `notificationsEnabled: Bool = true`, `monthlyBudgetCents: Int?`
- These mirror the global settings but are per-account

Both structs must be Codable for Keychain JSON storage and Sendable for Swift 6 concurrency.
  </action>
  <verify>
Build succeeds: `swift build 2>&1 | head -20`
  </verify>
  <done>
Account and AccountSettings models exist with all required properties and conform to Codable and Sendable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Constants and extend TokenManager for multi-account</name>
  <files>
    Tokemon/Utilities/Constants.swift
    Tokemon/Services/TokenManager.swift
  </files>
  <action>
**Constants.swift:**
Add new constant for Tokemon's own account metadata storage (separate from Claude Code's credentials):
```swift
/// Keychain service name for Tokemon account metadata (separate from Claude Code credentials)
static let accountsKeychainService = "com.tokemon.accounts"
```

**TokenManager.swift:**
Add overloaded static methods that accept a `username` parameter for multi-account credential access:

```swift
/// Read credentials for a specific account (by username)
static func getCredentials(username: String) throws -> ClaudeCredentials {
    let keychain = Keychain(service: Constants.keychainService)

    guard let json = try keychain.getString(username) else {
        throw TokenError.noCredentials
    }

    guard let data = json.data(using: .utf8) else {
        throw TokenError.noCredentials
    }

    return try JSONDecoder().decode(ClaudeCredentials.self, from: data)
}

/// Get valid access token for a specific account
static func getAccessToken(for username: String) throws -> String {
    let credentials = try getCredentials(username: username)
    let oauth = credentials.claudeAiOauth

    let expiresAtDate = Date(timeIntervalSince1970: Double(oauth.expiresAt) / 1000.0)
    let bufferDate = Date().addingTimeInterval(10 * 60)

    if expiresAtDate < bufferDate {
        throw TokenError.expired
    }

    if !oauth.scopes.contains("user:profile") {
        throw TokenError.insufficientScope
    }

    return oauth.accessToken
}

/// Get refresh token for a specific account
static func getRefreshToken(for username: String) throws -> String {
    let credentials = try getCredentials(username: username)
    return credentials.claudeAiOauth.refreshToken
}

/// Update Keychain credentials for a specific account
static func updateKeychainCredentials(response: OAuthTokenResponse, for username: String) throws {
    let keychain = Keychain(service: Constants.keychainService)
    var credentials = try getCredentials(username: username)

    credentials.claudeAiOauth.accessToken = response.accessToken
    credentials.claudeAiOauth.refreshToken = response.refreshToken

    let newExpiresAt = Int64(Date().timeIntervalSince1970 * 1000) + Int64(response.expiresIn) * 1000
    credentials.claudeAiOauth.expiresAt = newExpiresAt

    let encoder = JSONEncoder()
    let updatedData = try encoder.encode(credentials)
    guard let jsonString = String(data: updatedData, encoding: .utf8) else {
        throw TokenError.decodingError(
            NSError(domain: "TokenManager", code: -1, userInfo: [
                NSLocalizedDescriptionKey: "Failed to encode credentials to JSON string"
            ])
        )
    }

    try keychain.set(jsonString, key: username)
}
```

Keep the original parameterless methods for backward compatibility (they use NSUserName()).
  </action>
  <verify>
Build succeeds: `swift build 2>&1 | head -20`
  </verify>
  <done>
Constants has accountsKeychainService. TokenManager has username-parameterized overloads for getCredentials, getAccessToken, getRefreshToken, and updateKeychainCredentials.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create AccountManager service with migration</name>
  <files>
    Tokemon/Services/AccountManager.swift
  </files>
  <action>
Create AccountManager.swift following the LicenseManager pattern (Observable, MainActor, callbacks):

```swift
import Foundation
import KeychainAccess

/// Central coordinator for multi-account management.
/// Handles account list, active account selection, and credential access.
@Observable
@MainActor
final class AccountManager {

    // MARK: - Published State

    /// All registered accounts
    var accounts: [Account] = []

    /// Currently active account (nil if none)
    var activeAccount: Account?

    /// Whether account operations are in progress
    var isLoading: Bool = false

    /// Current error state
    var error: AccountError?

    // MARK: - Callbacks

    /// Called when active account changes (triggers UsageMonitor refresh)
    @ObservationIgnored
    var onActiveAccountChanged: ((Account?) -> Void)?

    // MARK: - Private

    @ObservationIgnored
    private let accountsKeychain: Keychain

    private let accountsKey = "accounts"
    private let activeAccountKey = "activeAccountId"
    private let migrationKey = "didMigrateToMultiAccount"

    // MARK: - Error Types

    enum AccountError: Error, LocalizedError {
        case accountNotFound
        case duplicateAccount
        case keychainError(String)
        case noCredentials

        var errorDescription: String? {
            switch self {
            case .accountNotFound: return "Account not found"
            case .duplicateAccount: return "Account already exists"
            case .keychainError(let msg): return "Keychain error: \(msg)"
            case .noCredentials: return "No credentials found for account"
            }
        }
    }

    // MARK: - Initialization

    init() {
        accountsKeychain = Keychain(service: Constants.accountsKeychainService)
            .accessibility(.afterFirstUnlockThisDeviceOnly)

        Task { @MainActor in
            await loadAccounts()
            await migrateFromSingleAccountIfNeeded()
        }
    }

    // MARK: - Public API

    /// Add a new account from OAuth credentials
    func addAccount(username: String, displayName: String? = nil) async throws -> Account {
        // Check if account already exists
        if let existing = accounts.first(where: { $0.username == username }) {
            return existing
        }

        // Verify credentials exist in Claude Code's keychain
        do {
            _ = try TokenManager.getCredentials(username: username)
        } catch {
            throw AccountError.noCredentials
        }

        let account = Account(displayName: displayName, username: username)
        accounts.append(account)
        try await saveAccounts()

        // If first account, make it active
        if accounts.count == 1 {
            try await setActiveAccount(account)
        }

        return account
    }

    /// Set the active account
    func setActiveAccount(_ account: Account) async throws {
        guard accounts.contains(where: { $0.id == account.id }) else {
            throw AccountError.accountNotFound
        }

        activeAccount = account
        UserDefaults.standard.set(account.id.uuidString, forKey: activeAccountKey)
        onActiveAccountChanged?(account)
    }

    /// Remove an account
    func removeAccount(_ account: Account) async throws {
        accounts.removeAll { $0.id == account.id }

        // Clear active account if it was removed
        if activeAccount?.id == account.id {
            activeAccount = accounts.first
            if let newActive = activeAccount {
                UserDefaults.standard.set(newActive.id.uuidString, forKey: activeAccountKey)
            } else {
                UserDefaults.standard.removeObject(forKey: activeAccountKey)
            }
            onActiveAccountChanged?(activeAccount)
        }

        try await saveAccounts()
    }

    /// Update account settings
    func updateAccountSettings(_ account: Account, settings: AccountSettings) async throws {
        guard let index = accounts.firstIndex(where: { $0.id == account.id }) else {
            throw AccountError.accountNotFound
        }

        accounts[index].settings = settings

        if activeAccount?.id == account.id {
            activeAccount = accounts[index]
        }

        try await saveAccounts()
    }

    /// Update account display name
    func updateDisplayName(_ account: Account, displayName: String) async throws {
        guard let index = accounts.firstIndex(where: { $0.id == account.id }) else {
            throw AccountError.accountNotFound
        }

        accounts[index].displayName = displayName

        if activeAccount?.id == account.id {
            activeAccount = accounts[index]
        }

        try await saveAccounts()
    }

    /// Get access token for active account
    func getActiveAccountAccessToken() throws -> String {
        guard let account = activeAccount else {
            throw AccountError.accountNotFound
        }
        return try TokenManager.getAccessToken(for: account.username)
    }

    // MARK: - Private Methods

    private func loadAccounts() async {
        isLoading = true
        defer { isLoading = false }

        do {
            if let data = try accountsKeychain.getData(accountsKey) {
                let decoder = JSONDecoder()
                decoder.dateDecodingStrategy = .iso8601
                accounts = try decoder.decode([Account].self, from: data)
            }

            // Restore active account
            if let activeId = UserDefaults.standard.string(forKey: activeAccountKey),
               let uuid = UUID(uuidString: activeId),
               let account = accounts.first(where: { $0.id == uuid }) {
                activeAccount = account
            } else if !accounts.isEmpty {
                // Default to first account
                activeAccount = accounts.first
            }
        } catch {
            self.error = .keychainError(error.localizedDescription)
        }
    }

    private func saveAccounts() async throws {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        let data = try encoder.encode(accounts)
        try accountsKeychain.set(data, key: accountsKey)
    }

    /// Migrate existing single-account user to multi-account structure
    private func migrateFromSingleAccountIfNeeded() async {
        guard !UserDefaults.standard.bool(forKey: migrationKey) else { return }

        // Check for existing Claude Code credentials (current user)
        let username = NSUserName()

        do {
            _ = try TokenManager.getCredentials(username: username)

            // Credentials exist - create account entry
            var account = Account(username: username)

            // Migrate existing alert settings
            let existingThreshold = UserDefaults.standard.integer(forKey: "alertThreshold")
            let existingNotifications = UserDefaults.standard.bool(forKey: "notificationsEnabled")

            account.settings.alertThreshold = existingThreshold > 0 ? existingThreshold : 80
            account.settings.notificationsEnabled = existingNotifications

            accounts.append(account)
            activeAccount = account

            try await saveAccounts()
            UserDefaults.standard.set(account.id.uuidString, forKey: activeAccountKey)

            print("[AccountManager] Migrated single account to multi-account: \(username)")
        } catch {
            // No existing credentials - nothing to migrate
            print("[AccountManager] No existing credentials to migrate")
        }

        UserDefaults.standard.set(true, forKey: migrationKey)
    }
}
```

Key points:
- Uses separate keychain service (Constants.accountsKeychainService) for account metadata
- Does NOT modify Claude Code's credentials keychain - only reads from it
- Migrates existing single-account users automatically on first launch
- Provides onActiveAccountChanged callback for triggering UsageMonitor refresh
  </action>
  <verify>
Build succeeds: `swift build 2>&1 | head -20`
  </verify>
  <done>
AccountManager service exists with account CRUD, active account tracking, automatic migration, and callback for account changes.
  </done>
</task>

</tasks>

<verification>
1. `swift build` completes without errors
2. Account and AccountSettings models are Codable and Sendable
3. TokenManager has username-parameterized overloads
4. AccountManager loads/saves accounts to separate keychain service
5. Migration logic creates account from existing credentials
</verification>

<success_criteria>
- Account model has id, username, displayName, settings, createdAt
- AccountSettings model has alertThreshold, notificationsEnabled
- TokenManager can read credentials for any username
- AccountManager can add, remove, switch accounts
- Single-account migration runs on first launch
- No modifications to Claude Code's keychain service
</success_criteria>

<output>
After completion, create `.planning/phases/07-multi-account/07-01-SUMMARY.md`
</output>
