---
phase: 02-alerts-notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ClaudeMon/Services/AlertManager.swift
  - ClaudeMon/Utilities/Constants.swift
  - ClaudeMon/ClaudeMonApp.swift
  - ClaudeMon/Services/UsageMonitor.swift
  - ClaudeMon/Views/MenuBar/UsageHeaderView.swift
autonomous: true

must_haves:
  truths:
    - "AlertManager exists as an observable service that tracks alert level (normal/warning/critical)"
    - "UsageMonitor notifies AlertManager on each usage update"
    - "Alert level changes from normal to warning when usage crosses threshold"
    - "Alert level changes to critical when usage reaches 100%"
    - "Menu bar shows '!' indicator when alert level is warning or critical"
    - "Popover header shows warning banner when alert level is critical"
    - "Alert state resets when 5-hour window resets"
  artifacts:
    - path: "ClaudeMon/Services/AlertManager.swift"
      provides: "Alert threshold checking, level tracking, notification state"
      min_lines: 80
    - path: "ClaudeMon/Utilities/Constants.swift"
      provides: "Default alert threshold constant"
      contains: "defaultAlertThreshold"
  key_links:
    - from: "ClaudeMon/Services/UsageMonitor.swift"
      to: "AlertManager.checkUsage"
      via: "onAlertCheck callback"
      pattern: "onAlertCheck\\?"
    - from: "ClaudeMon/ClaudeMonApp.swift"
      to: "AlertManager"
      via: "environment injection"
      pattern: "\\.environment\\(alertManager\\)"
    - from: "ClaudeMon/Views/MenuBar/UsageHeaderView.swift"
      to: "AlertManager.AlertLevel"
      via: "alertLevel parameter"
      pattern: "let alertLevel"
---

<objective>
Create AlertManager service for threshold-based alerts and integrate visual warning indicators into the menu bar and popover UI.

Purpose: Users need immediate visual feedback when approaching their Claude usage limits so they can pace their work.
Output: AlertManager.swift service, visual indicators in menu bar (!) and popover (warning banner), wired to UsageMonitor.
</objective>

<execution_context>
@/Users/richardparr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardparr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-alerts-notifications/02-RESEARCH.md

# Key existing files
@ClaudeMon/Services/UsageMonitor.swift
@ClaudeMon/ClaudeMonApp.swift
@ClaudeMon/Views/MenuBar/UsageHeaderView.swift
@ClaudeMon/Utilities/Constants.swift
@ClaudeMon/Models/UsageSnapshot.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AlertManager service with threshold checking and visual indicators</name>
  <files>
    ClaudeMon/Services/AlertManager.swift
    ClaudeMon/Utilities/Constants.swift
  </files>
  <action>
Create AlertManager.swift as an @Observable @MainActor service:

1. **Settings (UserDefaults-backed):**
   - `alertThreshold: Int` getter/setter (default 80, clamped 50-100)
   - `notificationsEnabled: Bool` getter/setter (default false)
   - `notificationPermissionGranted: Bool` (read-only, set after permission check)

2. **Alert state:**
   - `enum AlertLevel: Int, Comparable { case normal = 0, warning = 1, critical = 2 }`
   - `currentAlertLevel: AlertLevel` (observable, used by views)
   - `private var lastNotifiedLevel: AlertLevel` (prevents duplicate notifications)
   - `private var lastResetsAt: Date?` (detects window reset)

3. **checkUsage(_ usage: UsageSnapshot) method:**
   - Guard: return early if `!usage.hasPercentage`
   - Detect window reset: if `usage.resetsAt != lastResetsAt`, call `resetNotificationState()`
   - Calculate `alertLevel(for: Int) -> AlertLevel`: >=100 returns .critical, >=alertThreshold returns .warning, else .normal
   - Only fire when crossing INTO a higher level: `newLevel > currentAlertLevel && newLevel > lastNotifiedLevel`
   - Update `currentAlertLevel` on any level change

4. **resetNotificationState() method:**
   - Set both `lastNotifiedLevel` and `currentAlertLevel` to `.normal`

5. **Do NOT implement notifications yet** (that's Plan 02). Just stub `sendNotification(level:percentage:)` as a private no-op for now.

Update Constants.swift:
- Add `static let defaultAlertThreshold = 80`
  </action>
  <verify>
`swift build` succeeds. AlertManager.swift exists at ClaudeMon/Services/AlertManager.swift with AlertLevel enum, checkUsage method, and threshold settings.
  </verify>
  <done>
AlertManager compiles and exports AlertLevel enum and currentAlertLevel property for UI consumption.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire AlertManager to UsageMonitor and add visual indicators</name>
  <files>
    ClaudeMon/ClaudeMonApp.swift
    ClaudeMon/Services/UsageMonitor.swift
    ClaudeMon/Views/MenuBar/UsageHeaderView.swift
  </files>
  <action>
**UsageMonitor.swift changes:**
1. Add new callback: `@ObservationIgnored var onAlertCheck: ((_ usage: UsageSnapshot) -> Void)?`
2. In `refresh()`, after `onUsageChanged?(currentUsage)`, also call `onAlertCheck?(currentUsage)`

**ClaudeMonApp.swift changes:**
1. Add `@State private var alertManager = AlertManager()` alongside existing monitor state
2. In `.menuBarExtraAccess` callback (after `monitor.onUsageChanged` is set), wire up:
   ```swift
   monitor.onAlertCheck = { [alertManager] usage in
       Task { @MainActor in
           alertManager.checkUsage(usage)
       }
   }
   ```
3. Update StatusItemManager.update call to include alertLevel: `statusItemManager.update(with: monitor.currentUsage, error: monitor.error, alertLevel: alertManager.currentAlertLevel)`
4. Update onUsageChanged callback to pass alertLevel too
5. Inject alertManager into environment: `.environment(alertManager)` on PopoverContentView

**StatusItemManager.update changes:**
1. Add `alertLevel: AlertManager.AlertLevel` parameter
2. Priority for menu bar text/color:
   - If `.bothSourcesFailed` error: show "!" indicator, orange color (existing)
   - Else if alertLevel == .critical: append " !" to text, use red color (0.85, 0.25, 0.2)
   - Else if alertLevel == .warning: use gradient color but no extra indicator (threshold crossed but not critical)
   - Else: existing behavior (gradient for percentage, secondary for JSONL)

**UsageHeaderView.swift changes:**
1. Add `let alertLevel: AlertManager.AlertLevel` property
2. Above the main VStack content, add conditional warning banner:
   ```swift
   if alertLevel == .critical {
       HStack {
           Image(systemName: "exclamationmark.triangle.fill")
           Text("Usage limit reached")
       }
       .font(.caption)
       .foregroundStyle(.white)
       .padding(.horizontal, 12)
       .padding(.vertical, 6)
       .background(Color.red.opacity(0.9), in: Capsule())
   }
   ```
3. Update PopoverContentView to pass alertManager.currentAlertLevel to UsageHeaderView
  </action>
  <verify>
`swift build` succeeds. Run app, check that:
1. Menu bar shows normal percentage when usage < threshold
2. If usage >= threshold (80% default), confirm via print statement in AlertManager.checkUsage that level changes
  </verify>
  <done>
AlertManager is wired to UsageMonitor via onAlertCheck callback. StatusItemManager shows "!" for critical state. UsageHeaderView displays warning banner for critical alert level.
  </done>
</task>

</tasks>

<verification>
- `swift build` succeeds with no errors
- AlertManager.swift exists and defines AlertLevel enum
- UsageMonitor has onAlertCheck callback
- ClaudeMonApp injects alertManager into environment
- StatusItemManager.update accepts alertLevel parameter
- UsageHeaderView has alertLevel property and shows banner for .critical
</verification>

<success_criteria>
- AlertManager tracks alert level based on usage percentage and configurable threshold
- Visual indicators appear: "!" in menu bar for critical, warning banner in popover for critical
- Alert state resets when 5-hour window resets (detects resetsAt change)
- All code compiles and integrates cleanly with existing Phase 1 foundation
</success_criteria>

<output>
After completion, create `.planning/phases/02-alerts-notifications/02-01-SUMMARY.md`
</output>
