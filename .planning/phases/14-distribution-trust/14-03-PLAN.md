---
phase: 14-distribution-trust
plan: 03
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - Package.swift
  - Tokemon/Services/UpdateManager.swift
  - Tokemon/Views/MenuBar/UpdateBannerView.swift
  - Tokemon/Views/Settings/GeneralSettings.swift
  - Tokemon/TokemonApp.swift
  - Tokemon/Utilities/Constants.swift
autonomous: true

must_haves:
  truths:
    - "App checks for updates on launch"
    - "User sees banner notification when update is available"
    - "User can click to download/install update"
    - "User can enable/disable automatic update checks in Settings"
  artifacts:
    - path: "Tokemon/Services/UpdateManager.swift"
      provides: "Sparkle integration service for update checking"
      min_lines: 50
    - path: "Tokemon/Views/MenuBar/UpdateBannerView.swift"
      provides: "Update available notification banner"
      min_lines: 25
    - path: "Tokemon/Views/Settings/GeneralSettings.swift"
      provides: "Settings tab with auto-update toggle"
      min_lines: 40
  key_links:
    - from: "Tokemon/TokemonApp.swift"
      to: "Tokemon/Services/UpdateManager.swift"
      via: "App creates and holds UpdateManager"
      pattern: "UpdateManager"
    - from: "Tokemon/Services/UpdateManager.swift"
      to: "Sparkle"
      via: "SPUStandardUpdaterController integration"
      pattern: "SPUStandardUpdaterController"
    - from: "Tokemon/Views/MenuBar/UpdateBannerView.swift"
      to: "Tokemon/Services/UpdateManager.swift"
      via: "Banner reads updateAvailable state"
      pattern: "updateManager\\.updateAvailable"
---

<objective>
Integrate Sparkle framework for automatic updates and add update UI to the app.

Purpose: Enable users to receive and install updates without manually downloading DMGs. This establishes a standard macOS update experience and ensures users stay current.

Output:
- UpdateManager service wrapping Sparkle
- Update available banner in popover
- Settings tab for update preferences
</objective>

<execution_context>
@/Users/richardparr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardparr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-distribution-trust/14-01-SUMMARY.md
@Package.swift
@Tokemon/TokemonApp.swift
@Tokemon/Utilities/Constants.swift
@Tokemon/Views/Settings/SettingsView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Sparkle dependency and create UpdateManager</name>
  <files>
    Package.swift
    Tokemon/Services/UpdateManager.swift
    Tokemon/Utilities/Constants.swift
  </files>
  <action>
**Package.swift:**
Add Sparkle 2.x dependency:
```swift
.package(url: "https://github.com/sparkle-project/Sparkle.git", from: "2.6.0"),
```

Add to target dependencies:
```swift
.product(name: "Sparkle", package: "Sparkle"),
```

**Tokemon/Utilities/Constants.swift:**
Add Sparkle constants:
```swift
// MARK: - Sparkle Updates

/// URL to appcast.xml hosted on GitHub Pages or releases
static let sparkleAppcastURL = "https://tokemon.app/appcast.xml"

/// UserDefaults key for automatic update check preference
static let autoCheckUpdatesKey = "tokemon.autoCheckUpdates"
```

**Tokemon/Services/UpdateManager.swift:**
```swift
import Foundation
import Sparkle

/// Manages app updates via Sparkle framework.
/// Checks for updates on launch and provides UI-bindable state.
@Observable
@MainActor
final class UpdateManager: NSObject {

    /// Whether an update is available (for UI banner)
    var updateAvailable: Bool = false

    /// Version string of available update (e.g., "1.1.0")
    var availableVersion: String?

    /// Whether currently checking for updates
    var isChecking: Bool = false

    /// Error message if update check failed
    var error: String?

    /// Whether automatic update checks are enabled
    var autoCheckEnabled: Bool {
        get { UserDefaults.standard.object(forKey: Constants.autoCheckUpdatesKey) as? Bool ?? true }
        set { UserDefaults.standard.set(newValue, forKey: Constants.autoCheckUpdatesKey) }
    }

    /// Sparkle updater controller
    @ObservationIgnored
    private var updaterController: SPUStandardUpdaterController?

    override init() {
        super.init()
        setupSparkle()
    }

    private func setupSparkle() {
        // Create updater controller with this object as delegate
        updaterController = SPUStandardUpdaterController(
            startingUpdater: autoCheckEnabled,
            updaterDelegate: self,
            userDriverDelegate: nil
        )

        // Configure updater
        if let updater = updaterController?.updater {
            updater.automaticallyChecksForUpdates = autoCheckEnabled
            updater.automaticallyDownloadsUpdates = false // User must confirm
        }
    }

    /// Manually check for updates (from Settings or menu)
    func checkForUpdates() {
        guard let controller = updaterController else { return }
        isChecking = true
        error = nil
        controller.checkForUpdates(nil)
    }

    /// Open download page for available update
    func downloadUpdate() {
        guard let controller = updaterController else { return }
        controller.checkForUpdates(nil) // This will show the update UI
    }

    /// Update auto-check preference and reconfigure Sparkle
    func setAutoCheck(_ enabled: Bool) {
        autoCheckEnabled = enabled
        updaterController?.updater.automaticallyChecksForUpdates = enabled
    }
}

// MARK: - SPUUpdaterDelegate

extension UpdateManager: SPUUpdaterDelegate {

    nonisolated func feedURLString(for updater: SPUUpdater) -> String? {
        Constants.sparkleAppcastURL
    }

    nonisolated func updater(_ updater: SPUUpdater, didFindValidUpdate item: SUAppcastItem) {
        Task { @MainActor in
            self.updateAvailable = true
            self.availableVersion = item.displayVersionString
            self.isChecking = false
        }
    }

    nonisolated func updaterDidNotFindUpdate(_ updater: SPUUpdater, error: Error) {
        Task { @MainActor in
            self.updateAvailable = false
            self.availableVersion = nil
            self.isChecking = false
            // Only set error if it's not "no update available"
            if (error as NSError).code != SUError.noUpdateError.rawValue {
                self.error = error.localizedDescription
            }
        }
    }

    nonisolated func updater(_ updater: SPUUpdater, didAbortWithError error: Error) {
        Task { @MainActor in
            self.isChecking = false
            self.error = error.localizedDescription
        }
    }
}
```

Note: The @preconcurrency import may be needed if Sparkle has Sendable warnings in Swift 6.
  </action>
  <verify>
Run `swift build` to verify Package.swift compiles with Sparkle dependency.
Verify UpdateManager.swift compiles without errors.
  </verify>
  <done>
Sparkle added as dependency. UpdateManager wraps SPUStandardUpdaterController with @Observable state for UI binding.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create update banner and Settings UI</name>
  <files>
    Tokemon/Views/MenuBar/UpdateBannerView.swift
    Tokemon/Views/Settings/GeneralSettings.swift
    Tokemon/Views/Settings/SettingsView.swift
    Tokemon/TokemonApp.swift
  </files>
  <action>
**Tokemon/Views/MenuBar/UpdateBannerView.swift:**
```swift
import SwiftUI

/// Banner shown in popover when an update is available.
/// Displays version and button to download.
struct UpdateBannerView: View {
    @Environment(UpdateManager.self) private var updateManager

    var body: some View {
        if updateManager.updateAvailable {
            HStack {
                Image(systemName: "arrow.down.circle.fill")
                    .foregroundStyle(.blue)

                VStack(alignment: .leading, spacing: 2) {
                    Text("Update Available")
                        .font(.subheadline.weight(.medium))
                    if let version = updateManager.availableVersion {
                        Text("Version \(version)")
                            .font(.caption)
                            .foregroundStyle(.secondary)
                    }
                }

                Spacer()

                Button("Update") {
                    updateManager.downloadUpdate()
                }
                .buttonStyle(.borderedProminent)
                .controlSize(.small)
            }
            .padding(12)
            .background(.blue.opacity(0.1))
            .clipShape(RoundedRectangle(cornerRadius: 8))
        }
    }
}
```

**Tokemon/Views/Settings/GeneralSettings.swift:**
```swift
import SwiftUI

/// General settings tab with update preferences.
struct GeneralSettings: View {
    @Environment(UpdateManager.self) private var updateManager

    var body: some View {
        Form {
            Section("Updates") {
                Toggle("Check for updates automatically", isOn: Binding(
                    get: { updateManager.autoCheckEnabled },
                    set: { updateManager.setAutoCheck($0) }
                ))

                HStack {
                    Button("Check for Updates Now") {
                        updateManager.checkForUpdates()
                    }
                    .disabled(updateManager.isChecking)

                    if updateManager.isChecking {
                        ProgressView()
                            .controlSize(.small)
                    }
                }

                if let error = updateManager.error {
                    Text(error)
                        .foregroundStyle(.red)
                        .font(.caption)
                }

                if updateManager.updateAvailable, let version = updateManager.availableVersion {
                    HStack {
                        Text("Version \(version) available")
                            .foregroundStyle(.blue)
                        Spacer()
                        Button("Download") {
                            updateManager.downloadUpdate()
                        }
                    }
                }
            }

            Section("About") {
                LabeledContent("Version", value: Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String ?? "Unknown")
                LabeledContent("Build", value: Bundle.main.infoDictionary?["CFBundleVersion"] as? String ?? "Unknown")
            }
        }
        .formStyle(.grouped)
    }
}
```

**Tokemon/Views/Settings/SettingsView.swift:**
Add GeneralSettings as a new tab (place FIRST before Profiles):
- Add `case general` to the TabSelection enum or add new Tab
- Add `Tab("General", systemImage: "gear") { GeneralSettings() }` before other tabs
- Pass `.environment(updateManager)` if needed

**Tokemon/TokemonApp.swift:**
- Add `@State private var updateManager = UpdateManager()`
- Pass to environments: `.environment(updateManager)`
- Wire to SettingsWindowController: `SettingsWindowController.shared.setUpdateManager(updateManager)`

Also update SettingsWindowController.swift to add:
```swift
private var updateManager: UpdateManager?

func setUpdateManager(_ manager: UpdateManager) {
    self.updateManager = manager
}
```

And pass to SettingsView in the window.
  </action>
  <verify>
Run `swift build` to verify all UI compiles.
Check that GeneralSettings appears as first tab in Settings.
  </verify>
  <done>
UpdateBannerView shows update notification in popover.
GeneralSettings tab has auto-update toggle and manual check button.
UpdateManager wired through app environment.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate update banner into popover and add appcast generation</name>
  <files>
    Tokemon/Views/MenuBar/PopoverContentView.swift
    scripts/generate-appcast.sh
    Tokemon/TokemonApp.swift
  </files>
  <action>
**Tokemon/Views/MenuBar/PopoverContentView.swift:**
Add UpdateBannerView after the error banner but before the main content:
```swift
// After ErrorBannerView
UpdateBannerView()
```

The banner will only show when `updateManager.updateAvailable` is true.

**Tokemon/TokemonApp.swift:**
Update popoverHeight computed property to account for update banner:
```swift
// Add in popoverHeight
let updateBannerHeight: CGFloat = 56

// In the height calculation
if updateManager.updateAvailable {
    height += updateBannerHeight
}
```

**scripts/generate-appcast.sh:**
Create script to generate Sparkle appcast.xml:
```bash
#!/bin/bash
set -e

# Generate appcast.xml for Sparkle updates
# Run after creating a new release DMG

VERSION=$1
DMG_PATH=$2

if [ -z "$VERSION" ] || [ -z "$DMG_PATH" ]; then
    echo "Usage: ./generate-appcast.sh <version> <dmg-path>"
    exit 1
fi

# Get file info
FILE_SIZE=$(stat -f%z "$DMG_PATH")
PUB_DATE=$(date -R)

# For EdDSA signature, use Sparkle's sign_update tool
# This requires the private key from Sparkle setup
if [ -f "$SPARKLE_ED_PRIVATE_KEY" ]; then
    SIGNATURE=$(./bin/sign_update "$DMG_PATH")
else
    echo "Warning: SPARKLE_ED_PRIVATE_KEY not set, skipping signature"
    SIGNATURE=""
fi

cat > appcast.xml << EOF
<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle">
  <channel>
    <title>Tokemon Updates</title>
    <link>https://tokemon.app/appcast.xml</link>
    <description>Most recent changes with links to updates.</description>
    <language>en</language>
    <item>
      <title>Version ${VERSION}</title>
      <pubDate>${PUB_DATE}</pubDate>
      <sparkle:version>${VERSION}</sparkle:version>
      <sparkle:shortVersionString>${VERSION}</sparkle:shortVersionString>
      <sparkle:minimumSystemVersion>14.0</sparkle:minimumSystemVersion>
      <enclosure
        url="https://github.com/YOUR_ORG/tokemon/releases/download/v${VERSION}/Tokemon-${VERSION}.dmg"
        length="${FILE_SIZE}"
        type="application/octet-stream"
        ${SIGNATURE:+sparkle:edSignature=\"$SIGNATURE\"}
      />
    </item>
  </channel>
</rss>
EOF

echo "Generated appcast.xml for version ${VERSION}"
```

Update .github/workflows/release.yml to generate and upload appcast:
```yaml
      - name: Generate appcast
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          chmod +x scripts/generate-appcast.sh
          ./scripts/generate-appcast.sh $VERSION Tokemon-$VERSION.dmg

      - name: Upload appcast to releases
        uses: softprops/action-gh-release@v1
        with:
          files: appcast.xml
```
  </action>
  <verify>
Run `swift build` to verify PopoverContentView compiles.
Run `cat scripts/generate-appcast.sh | head -20` to verify script structure.
  </verify>
  <done>
Update banner integrated into popover.
Appcast generation script created.
Release workflow generates and uploads appcast.xml.
  </done>
</task>

</tasks>

<verification>
1. `swift build` compiles successfully with Sparkle dependency
2. UpdateManager exists with SPUStandardUpdaterController integration
3. GeneralSettings shows update toggle and check button
4. UpdateBannerView renders when updateAvailable is true
5. Appcast generation script produces valid XML
</verification>

<success_criteria>
- Sparkle framework integrated via SPM
- UpdateManager provides @Observable state for update availability
- User can toggle automatic update checks in Settings
- User sees update banner in popover when new version available
- Appcast.xml generated for each release
</success_criteria>

<output>
After completion, create `.planning/phases/14-distribution-trust/14-03-SUMMARY.md`
</output>
