---
phase: 11-multi-profile-foundation
plan: 03
type: execute
wave: 3
depends_on: ["11-01", "11-02"]
files_modified:
  - Tokemon/Services/UsageMonitor.swift
  - Tokemon/Services/OAuthClient.swift
  - Tokemon/Services/ProfileManager.swift
  - Tokemon/Views/MenuBar/PopoverContentView.swift
  - Tokemon/Views/MenuBar/UsageHeaderView.swift
autonomous: true

must_haves:
  truths:
    - "App fetches usage for all profiles simultaneously on each polling interval"
    - "Each profile's cached lastUsage is updated after polling"
    - "User can see all profiles' usage summaries in the popover"
    - "Active profile's usage is shown prominently (existing header)"
    - "Inactive profiles' usage is shown in a compact summary section"
    - "Profile usage polling uses each profile's stored credentials (not system keychain)"
  artifacts:
    - path: "Tokemon/Services/OAuthClient.swift"
      provides: "Credential-parameterized OAuth fetch method"
      contains: "fetchUsage.*credentials"
    - path: "Tokemon/Views/MenuBar/PopoverContentView.swift"
      provides: "Multi-profile usage summary section"
      contains: "AllProfilesUsageView\\|profileUsage\\|otherProfiles"
  key_links:
    - from: "Tokemon/Services/UsageMonitor.swift"
      to: "Tokemon/Services/ProfileManager.swift"
      via: "reads profiles array to poll all"
      pattern: "profileManager.*profiles"
    - from: "Tokemon/Services/UsageMonitor.swift"
      to: "Tokemon/Services/OAuthClient.swift"
      via: "passes profile credentials to fetch"
      pattern: "fetchUsage.*credentialsJSON\\|fetchUsageForProfile"
    - from: "Tokemon/Views/MenuBar/PopoverContentView.swift"
      to: "Tokemon/Services/ProfileManager.swift"
      via: "reads profile lastUsage for display"
      pattern: "profile\\.lastUsage\\|profiles.*filter"
---

<objective>
Enable simultaneous usage polling for all profiles and display all profiles' usage in the popover.

Purpose: PROF-06 requires users to see all profiles' usage simultaneously. This means polling usage for ALL profiles (not just the active one) and showing a summary of each profile's usage in the popover alongside the main active profile display.

Output: Updated UsageMonitor with multi-profile polling, OAuthClient with credential-parameterized fetch, multi-profile usage display in popover.
</objective>

<execution_context>
@/Users/richardparr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardparr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-multi-profile-foundation/11-01-SUMMARY.md
@.planning/phases/11-multi-profile-foundation/11-02-SUMMARY.md

Key codebase files to reference:
@Tokemon/Services/UsageMonitor.swift (modify polling to handle all profiles)
@Tokemon/Services/OAuthClient.swift (add credential-parameterized fetch)
@Tokemon/Services/TokenManager.swift (understand credential structure)
@Tokemon/Views/MenuBar/PopoverContentView.swift (add multi-profile display)
@Tokemon/Views/MenuBar/UsageHeaderView.swift (reference for usage display patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add credential-parameterized OAuth fetch and multi-profile polling</name>
  <files>Tokemon/Services/OAuthClient.swift, Tokemon/Services/UsageMonitor.swift, Tokemon/Services/ProfileManager.swift</files>
  <action>
**Update `Tokemon/Services/OAuthClient.swift`:**

Add a new static method that accepts a credentials JSON string directly (instead of reading from the system keychain):

```swift
/// Fetch usage using credentials stored in a profile (not from system keychain).
/// - Parameter credentialsJSON: The raw JSON string containing claudeAiOauth credentials.
/// - Returns: The decoded OAuthUsageResponse.
/// - Throws: OAuthError or TokenManager.TokenError if credentials are invalid/expired.
static func fetchUsageWithCredentials(_ credentialsJSON: String) async throws -> OAuthUsageResponse {
    guard let data = credentialsJSON.data(using: .utf8) else {
        throw OAuthError.invalidResponse
    }

    let credentials = try JSONDecoder().decode(
        TokenManager.ClaudeCredentials.self,
        from: data
    )
    let oauth = credentials.claudeAiOauth

    // Check expiry with 10-minute buffer
    let expiresAtDate = Date(timeIntervalSince1970: Double(oauth.expiresAt) / 1000.0)
    let bufferDate = Date().addingTimeInterval(10 * 60)

    if expiresAtDate < bufferDate {
        // Try to refresh using the stored refresh token
        let tokenResponse = try await TokenManager.refreshAccessToken(
            refreshToken: oauth.refreshToken
        )
        // Return usage with the refreshed token
        // Note: We don't write back to system keychain here -- only the active profile's
        // credentials get written to keychain on switch
        return try await fetchUsage(accessToken: tokenResponse.accessToken)
    }

    return try await fetchUsage(accessToken: oauth.accessToken)
}
```

Also add a method that tries manual session key auth:

```swift
/// Fetch usage using a manual session key (API key style auth).
/// - Parameters:
///   - sessionKey: The Claude session key.
///   - orgId: Optional organization ID.
/// - Returns: The decoded OAuthUsageResponse.
static func fetchUsageWithSessionKey(_ sessionKey: String, orgId: String? = nil) async throws -> OAuthUsageResponse {
    // Session keys are used as Bearer tokens directly
    return try await fetchUsage(accessToken: sessionKey)
}
```

Keep ALL existing methods unchanged. These are additive.

**Update `Tokemon/Services/UsageMonitor.swift`:**

1. Add a reference to ProfileManager (set by TokemonApp after init):
   ```swift
   @ObservationIgnored
   var profileManager: ProfileManager?
   ```

2. Add a method `refreshAllProfiles()` that polls usage for ALL profiles with credentials:
   ```swift
   /// Fetch usage for all profiles simultaneously (for PROF-06 multi-profile display).
   /// Updates each profile's lastUsage in ProfileManager.
   /// Called after the main refresh() completes successfully.
   func refreshAllProfiles() async {
       guard let profileManager else { return }

       // Fetch usage for all profiles that have credentials (excluding active -- already fetched)
       let otherProfiles = profileManager.profiles.filter {
           $0.id != profileManager.activeProfileId && $0.hasCredentials
       }

       // Use TaskGroup for parallel fetching
       await withTaskGroup(of: (UUID, UsageSnapshot?).self) { group in
           for profile in otherProfiles {
               group.addTask {
                   do {
                       let response: OAuthUsageResponse
                       if let credJSON = profile.cliCredentialsJSON {
                           response = try await OAuthClient.fetchUsageWithCredentials(credJSON)
                       } else if let sessionKey = profile.claudeSessionKey {
                           response = try await OAuthClient.fetchUsageWithSessionKey(
                               sessionKey,
                               orgId: profile.organizationId
                           )
                       } else {
                           return (profile.id, nil)
                       }
                       return (profile.id, response.toSnapshot())
                   } catch {
                       print("[UsageMonitor] Failed to fetch usage for profile \(profile.name): \(error)")
                       return (profile.id, nil)
                   }
               }
           }

           for await (profileId, snapshot) in group {
               if let snapshot {
                   profileManager.updateProfileUsage(profileId: profileId, usage: snapshot)
               }
           }
       }
   }
   ```

3. At the END of the `refresh()` method, after a successful data fetch (after `onAlertCheck?(currentUsage)` and `await recordHistory(for: currentUsage)`) but still within the OAuth success or JSONL success blocks, add:
   ```swift
   // Also update the active profile's cached usage
   if let profileManager, let activeId = profileManager.activeProfileId {
       profileManager.updateProfileUsage(profileId: activeId, usage: currentUsage)
   }
   // Fetch usage for all other profiles
   await refreshAllProfiles()
   ```

   Add this to BOTH the OAuth success block and the JSONL success block in refresh().

**Update `Tokemon/Services/ProfileManager.swift`:**

Add a method to update a profile's cached usage:

```swift
/// Update a profile's cached usage snapshot (called by UsageMonitor after polling).
func updateProfileUsage(profileId: UUID, usage: UsageSnapshot) {
    guard let index = profiles.firstIndex(where: { $0.id == profileId }) else { return }
    profiles[index].lastUsage = usage
    saveProfiles()
}
```

Note: `saveProfiles()` is called here to persist the cached usage. If this is too frequent (every polling interval x number of profiles), consider debouncing or only saving usage periodically. For now, saving each time is fine since UserDefaults writes are fast.
  </action>
  <verify>
`swift build 2>&1 | tail -5` compiles without errors. OAuthClient.swift contains `fetchUsageWithCredentials` method. UsageMonitor.swift contains `refreshAllProfiles` method and `profileManager` property.
  </verify>
  <done>All profiles are polled for usage on each refresh cycle. Active profile's usage comes from the main refresh flow, other profiles are fetched in parallel via TaskGroup. Each profile's lastUsage is updated in ProfileManager.</done>
</task>

<task type="auto">
  <name>Task 2: Display all profiles' usage in the popover</name>
  <files>Tokemon/Views/MenuBar/PopoverContentView.swift, Tokemon/TokemonApp.swift</files>
  <action>
**Update `Tokemon/Views/MenuBar/PopoverContentView.swift`:**

Add a multi-profile usage summary section that shows all profiles' usage below the main usage display (after UsageDetailView, before the chart section). Only show when there are 2+ profiles:

```swift
// Multi-profile usage summary (only when 2+ profiles)
if profileManager.profiles.count > 1 {
    Divider()

    VStack(alignment: .leading, spacing: 6) {
        Text("All Profiles")
            .font(.caption)
            .foregroundStyle(.secondary)
            .textCase(.uppercase)

        ForEach(profileManager.profiles) { profile in
            HStack {
                // Active indicator
                Circle()
                    .fill(profile.id == profileManager.activeProfileId
                        ? Color.green : Color.clear)
                    .frame(width: 6, height: 6)

                Text(profile.name)
                    .font(.callout)
                    .lineLimit(1)

                Spacer()

                // Usage percentage or status
                if let usage = profile.lastUsage, usage.hasPercentage {
                    Text("\(Int(usage.primaryPercentage))%")
                        .font(.callout.monospacedDigit())
                        .foregroundStyle(usageColor(for: usage.primaryPercentage))
                } else if !profile.hasCredentials {
                    Text("No creds")
                        .font(.caption)
                        .foregroundStyle(.tertiary)
                } else {
                    Text("--")
                        .font(.callout)
                        .foregroundStyle(.tertiary)
                }
            }
        }
    }
}
```

Add a helper for usage color in PopoverContentView (or use GradientColors):
```swift
private func usageColor(for percentage: Double) -> Color {
    if percentage >= 100 {
        return Color(nsColor: GradientColors.color(for: percentage))
    } else if percentage >= Double(alertManager.alertThreshold) {
        return Color(nsColor: GradientColors.color(for: percentage))
    }
    return .primary
}
```

**Update `Tokemon/TokemonApp.swift`:**

In the `menuBarExtraAccess` closure, wire the profileManager to UsageMonitor:

```swift
monitor.profileManager = profileManager
```

Place this alongside the other wiring (after `SettingsWindowController.shared.setMonitor(monitor)` etc.).

Also update the `popoverHeight` computation to account for the multi-profile section. Add height for each additional profile (~24px per profile row + ~32px for header/divider):

```swift
if profileManager.profiles.count > 1 {
    let profileSwitcherHeight: CGFloat = 28   // Switcher dropdown
    let profileSummaryHeader: CGFloat = 32    // "All Profiles" header + divider
    let profileRowHeight: CGFloat = 24        // Per profile row
    height += profileSwitcherHeight + profileSummaryHeader + (CGFloat(profileManager.profiles.count) * profileRowHeight)
}
```

Replace the simpler `profileManager.profiles.count > 1` height addition from Plan 02 with this more accurate calculation.
  </action>
  <verify>
`swift build 2>&1 | tail -5` compiles without errors. PopoverContentView.swift contains "All Profiles" section. TokemonApp.swift sets `monitor.profileManager = profileManager`.
  </verify>
  <done>All profiles' usage is displayed simultaneously in the popover. Active profile shown prominently in the existing header, all profiles listed in a summary section with usage percentages. Popover height dynamically adjusts for the number of profiles. PROF-06 complete.</done>
</task>

</tasks>

<verification>
1. `swift build` compiles successfully
2. OAuthClient has credential-parameterized fetch methods
3. UsageMonitor polls all profiles on each refresh cycle
4. PopoverContentView shows all profiles' usage when 2+ profiles exist
5. Popover height adjusts dynamically for profile count
6. Profile usage data persists across app restarts (via lastUsage in ProfileManager)
</verification>

<success_criteria>
- All profiles' usage is fetched simultaneously on each polling interval
- Active profile uses the main OAuth/JSONL flow (unchanged behavior)
- Inactive profiles use their stored credentials for direct API calls
- All profiles' usage is visible in the popover (PROF-06)
- Failed credential fetches for inactive profiles don't affect the active profile's display
- Popover height adjusts correctly for the number of profiles
</success_criteria>

<output>
After completion, create `.planning/phases/11-multi-profile-foundation/11-03-SUMMARY.md`
</output>
