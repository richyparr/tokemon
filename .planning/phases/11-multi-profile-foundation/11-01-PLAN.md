---
phase: 11-multi-profile-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Tokemon/Models/Profile.swift
  - Tokemon/Services/ProfileManager.swift
  - Tokemon/Utilities/Constants.swift
  - Tokemon/Services/TokenManager.swift
autonomous: true

must_haves:
  truths:
    - "Profile struct can store OAuth credentials (session key, org ID, CLI credentials JSON) internally"
    - "ProfileManager can create a named profile and persist it"
    - "ProfileManager can sync current system keychain credentials into a profile"
    - "ProfileManager can accept manually-entered session keys for a profile"
    - "ProfileManager can write a profile's credentials to the system keychain (switch)"
    - "ProfileManager can delete a profile"
    - "ProfileManager tracks which profile is active"
  artifacts:
    - path: "Tokemon/Models/Profile.swift"
      provides: "Profile model with credential storage"
      contains: "struct Profile"
    - path: "Tokemon/Services/ProfileManager.swift"
      provides: "Profile CRUD, sync, switch, and persistence"
      contains: "class ProfileManager"
  key_links:
    - from: "Tokemon/Services/ProfileManager.swift"
      to: "Tokemon/Services/TokenManager.swift"
      via: "readSystemCredentials using /usr/bin/security CLI"
      pattern: "security.*find-generic-password"
    - from: "Tokemon/Services/ProfileManager.swift"
      to: "system keychain"
      via: "writeSystemCredentials using /usr/bin/security CLI"
      pattern: "security.*add-generic-password"
---

<objective>
Create the Profile model and ProfileManager service that implements the copy/switch credential architecture for multi-profile support.

Purpose: This is the data layer foundation for all profile operations. Profiles store credentials INSIDE the app (not in the system keychain), and on switch, write the selected profile's credentials TO the system keychain for Claude Code to use. This avoids the keychain conflicts that caused the v2.0 multi-account feature to be removed.

Output: Profile.swift model, ProfileManager.swift service with full CRUD + keychain sync/write operations.
</objective>

<execution_context>
@/Users/richardparr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardparr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

Key codebase files to reference:
@Tokemon/Services/TokenManager.swift (existing keychain access patterns)
@Tokemon/Utilities/Constants.swift (existing keychain service constants)
@Tokemon/Models/UsageSnapshot.swift (model pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Profile model and Constants updates</name>
  <files>Tokemon/Models/Profile.swift, Tokemon/Utilities/Constants.swift</files>
  <action>
Create `Tokemon/Models/Profile.swift` with a `Profile` struct that stores credentials INSIDE the app:

```swift
struct Profile: Identifiable, Codable, Sendable {
    let id: UUID
    var name: String                    // User-provided display name (e.g., "Work", "Personal")
    var claudeSessionKey: String?       // OAuth session key (from manual entry)
    var organizationId: String?         // Org ID if applicable
    var cliCredentialsJSON: String?     // Full JSON blob copied from system keychain
    var isDefault: Bool                 // True for the first/primary profile
    var createdAt: Date
    var lastUsage: UsageSnapshot?       // Cached usage for quick display (PROF-06)
    var lastSynced: Date?               // When credentials were last synced from keychain

    /// Whether this profile has any credentials (either synced or manual)
    var hasCredentials: Bool {
        cliCredentialsJSON != nil || claudeSessionKey != nil
    }

    /// Create a new empty profile with the given name
    static func create(name: String, isDefault: Bool = false) -> Profile {
        Profile(
            id: UUID(),
            name: name,
            isDefault: isDefault,
            createdAt: Date()
        )
    }
}
```

Make sure Profile conforms to Codable and Sendable for persistence and Swift 6 concurrency.

In `Tokemon/Utilities/Constants.swift`, add a new constant for profile storage (reuse the existing `accountsKeychainService` constant which is already `"ai.tokemon.accounts"`, or add a new one specifically for profiles):

```swift
// MARK: - Multi-Profile
/// UserDefaults key for profile storage
static let profilesStorageKey = "tokemon.profiles"
/// UserDefaults key for active profile ID
static let activeProfileIdKey = "tokemon.activeProfileId"
/// Keychain service for Claude Code credentials (same as keychainService, used for read/write operations)
static let claudeCodeKeychainService = "Claude Code-credentials"
```

Note: `claudeCodeKeychainService` is the same value as the existing `keychainService` -- this is intentional as the copy/switch pattern reads FROM and writes TO Claude Code's keychain. The existing `keychainService` constant can continue to be used; adding `claudeCodeKeychainService` as an alias makes the intent clearer in ProfileManager.

Do NOT remove the existing `accountsKeychainService` constant -- it may be referenced elsewhere.
  </action>
  <verify>
`swift build 2>&1 | tail -5` compiles without errors. Profile.swift exists and contains struct Profile with Identifiable, Codable, Sendable conformance.
  </verify>
  <done>Profile model exists with credential storage fields, Constants updated with profile storage keys.</done>
</task>

<task type="auto">
  <name>Task 2: Create ProfileManager service with CRUD and keychain operations</name>
  <files>Tokemon/Services/ProfileManager.swift</files>
  <action>
Create `Tokemon/Services/ProfileManager.swift` as an @Observable @MainActor class:

```swift
@Observable
@MainActor
final class ProfileManager {
    // MARK: - State
    var profiles: [Profile] = []
    var activeProfileId: UUID?

    var activeProfile: Profile? {
        profiles.first { $0.id == activeProfileId }
    }

    // Callback for when active profile changes (wired by TokemonApp in Plan 02)
    @ObservationIgnored
    var onActiveProfileChanged: ((_ profile: Profile?) -> Void)?

    // MARK: - Initialization
    init() {
        loadProfiles()
        // If no profiles exist, create a default one and try to sync system credentials
        if profiles.isEmpty {
            let defaultProfile = Profile.create(name: "Default", isDefault: true)
            profiles.append(defaultProfile)
            activeProfileId = defaultProfile.id
            // Try to sync credentials from system keychain into the default profile
            syncCredentialsFromKeychain(for: defaultProfile.id)
            saveProfiles()
        }
    }
}
```

**CRUD operations:**
- `createProfile(name: String) -> Profile` -- creates new profile, appends to list, saves, returns it
- `deleteProfile(id: UUID)` -- removes profile (cannot delete the last profile; cannot delete the active profile unless another exists to switch to; if deleting the default profile, mark another as default)
- `updateProfileName(id: UUID, name: String)` -- updates display name, saves
- `setActiveProfile(id: UUID)` -- sets activeProfileId, calls `writeCredentialsToKeychain(for:)` to push credentials to system keychain, fires onActiveProfileChanged callback, saves

**Keychain sync operations (copy/switch pattern):**

`syncCredentialsFromKeychain(for profileId: UUID)`:
- Reads credentials from the SYSTEM keychain using Process + `/usr/bin/security`:
  ```swift
  let process = Process()
  process.executableURL = URL(fileURLWithPath: "/usr/bin/security")
  process.arguments = [
      "find-generic-password",
      "-s", Constants.keychainService,  // "Claude Code-credentials"
      "-a", NSUserName(),
      "-w"  // Output password data only
  ]
  ```
- Stores the raw JSON string in `profile.cliCredentialsJSON`
- Updates `profile.lastSynced = Date()`
- Saves profiles

`enterManualSessionKey(for profileId: UUID, sessionKey: String, orgId: String?)`:
- Sets `profile.claudeSessionKey = sessionKey`
- Sets `profile.organizationId = orgId`
- Saves profiles

`writeCredentialsToKeychain(for profileId: UUID)`:
- Gets the profile's stored credentials (prefer cliCredentialsJSON over manual session key)
- Writes TO the system keychain using Process + `/usr/bin/security`:
  ```swift
  // First delete existing entry
  let deleteProcess = Process()
  deleteProcess.executableURL = URL(fileURLWithPath: "/usr/bin/security")
  deleteProcess.arguments = [
      "delete-generic-password",
      "-s", Constants.keychainService,
      "-a", NSUserName()
  ]
  // Ignore errors (entry may not exist)
  try? deleteProcess.run()
  deleteProcess.waitUntilExit()

  // Then add new entry
  let addProcess = Process()
  addProcess.executableURL = URL(fileURLWithPath: "/usr/bin/security")
  addProcess.arguments = [
      "add-generic-password",
      "-s", Constants.keychainService,
      "-a", NSUserName(),
      "-w", credentialsJSON,
      "-U"  // Update if exists
  ]
  ```
- If the profile only has a manual session key (no cliCredentialsJSON), construct a minimal ClaudeCredentials JSON structure matching TokenManager.ClaudeCredentials format and write that

**Persistence (UserDefaults):**
- `saveProfiles()` -- encode `profiles` array as JSON to UserDefaults key `Constants.profilesStorageKey`, also save `activeProfileId` to `Constants.activeProfileIdKey`
- `loadProfiles()` -- decode from UserDefaults, restore `activeProfileId`

**IMPORTANT implementation notes:**
- Use `Process` (not KeychainAccess library) for system keychain read/write because we need to read/write to Claude Code's keychain entry specifically. KeychainAccess is fine for the app's own keychain services, but the system `/usr/bin/security` CLI is what Claude Usage Tracker uses and avoids permission issues.
- `writeCredentialsToKeychain` should use the `-U` flag (update if exists) on `add-generic-password` to avoid "duplicate item" errors.
- All Process operations should capture stderr for error logging.
- The class should print debug logs with `[ProfileManager]` prefix.
  </action>
  <verify>
`swift build 2>&1 | tail -5` compiles without errors. ProfileManager.swift exists with createProfile, deleteProfile, syncCredentialsFromKeychain, writeCredentialsToKeychain, enterManualSessionKey, setActiveProfile methods.
  </verify>
  <done>ProfileManager service exists with full CRUD, keychain sync (read from system keychain), keychain write (push to system keychain on switch), manual session key entry, and UserDefaults persistence. Copy/switch architecture fully implemented at the service layer.</done>
</task>

</tasks>

<verification>
1. `swift build` compiles successfully with no errors
2. Profile.swift contains struct with Identifiable, Codable, Sendable
3. ProfileManager.swift contains @Observable @MainActor class with all required methods
4. ProfileManager uses Process + /usr/bin/security for keychain operations (not KeychainAccess for system keychain)
5. Constants.swift contains profile storage keys
</verification>

<success_criteria>
- Profile model can store OAuth credentials internally (cliCredentialsJSON, claudeSessionKey)
- ProfileManager can create, read, update, delete profiles
- ProfileManager can sync from system keychain (copy) and write to system keychain (switch)
- ProfileManager can accept manual session keys
- All code compiles with Swift 6 strict concurrency
</success_criteria>

<output>
After completion, create `.planning/phases/11-multi-profile-foundation/11-01-SUMMARY.md`
</output>
