---
phase: 13-terminal-statusline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Tokemon/Models/StatuslineConfig.swift
  - Tokemon/Services/StatuslineExporter.swift
  - Tokemon/Utilities/Constants.swift
  - Tokemon/Resources/tokemon-statusline.sh
autonomous: true

must_haves:
  truths:
    - "Usage data is written to ~/.tokemon/statusline as a plain text file on every refresh"
    - "The statusline file contains session %, weekly %, and reset timer fields"
    - "A shell helper script can be sourced in bash/zsh to display the statusline in the prompt"
    - "The shell helper reads the cache file and formats output with ANSI colors"
  artifacts:
    - path: "Tokemon/Models/StatuslineConfig.swift"
      provides: "StatuslineConfig model with format options"
      contains: "struct StatuslineConfig"
    - path: "Tokemon/Services/StatuslineExporter.swift"
      provides: "StatuslineExporter service that writes usage to disk"
      contains: "class StatuslineExporter"
    - path: "Tokemon/Resources/tokemon-statusline.sh"
      provides: "Shell helper script for bash/zsh prompt integration"
      contains: "tokemon_statusline"
  key_links:
    - from: "Tokemon/Services/StatuslineExporter.swift"
      to: "~/.tokemon/statusline"
      via: "FileManager write on export()"
      pattern: "write.*statusline"
    - from: "Tokemon/Resources/tokemon-statusline.sh"
      to: "~/.tokemon/statusline"
      via: "cat/read the cache file"
      pattern: "tokemon/statusline"
---

<objective>
Create the StatuslineExporter service and shell helper script that enable terminal prompt integration.

Purpose: This is the core data pipeline for the terminal statusline feature -- the app writes formatted usage data to a cache file on disk, and a shell function reads it for display in the prompt. This is the highest-demand feature with 11 duplicate GitHub issues on the competing tool.

Output: StatuslineConfig model, StatuslineExporter service, shell helper script, updated Constants.
</objective>

<execution_context>
@/Users/richardparr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardparr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@Tokemon/Services/UsageMonitor.swift
@Tokemon/Models/UsageSnapshot.swift
@Tokemon/Utilities/Constants.swift
@Tokemon/TokemonApp.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StatuslineConfig model and StatuslineExporter service</name>
  <files>
    Tokemon/Models/StatuslineConfig.swift
    Tokemon/Services/StatuslineExporter.swift
    Tokemon/Utilities/Constants.swift
  </files>
  <action>
**StatuslineConfig.swift:**
Create a `struct StatuslineConfig: Codable, Sendable` with these fields:
- `enabled: Bool` (default false) -- master toggle for statusline export
- `showSessionPercent: Bool` (default true) -- show 5-hour session %
- `showWeeklyPercent: Bool` (default true) -- show 7-day weekly %
- `showResetTimer: Bool` (default true) -- show time until reset
- `separator: String` (default " | ") -- field separator
- `useColors: Bool` (default true) -- whether to include ANSI color codes
- `prefix: String` (default "[") -- before the statusline content
- `suffix: String` (default "]") -- after the statusline content

Store/load via UserDefaults using a single JSON blob under key `tokemon.statuslineConfig`. Add a `static let defaultConfig` property. Add `save()` and `static func load() -> StatuslineConfig` methods.

**StatuslineExporter.swift:**
Create `@MainActor final class StatuslineExporter` (NOT @Observable -- this is a background service, not a view model). Fields:
- `private var config: StatuslineConfig`
- `private let statuslineDirectory: URL` -- `~/.tokemon/`
- `private let statuslineFile: URL` -- `~/.tokemon/statusline`

Methods:
- `init()` -- loads config from UserDefaults, creates `~/.tokemon/` directory if needed
- `func reloadConfig()` -- re-reads config from UserDefaults
- `func export(_ usage: UsageSnapshot)` -- writes formatted statusline to disk. If `config.enabled` is false, delete the statusline file if it exists (clean up) and return early.

The `export()` method builds a plain text string with the configured fields:
- Session %: format as `S:XX%` (e.g., `S:42%`)
- Weekly %: format as `W:XX%` (e.g., `W:78%`)
- Reset timer: format as `R:XhYm` (e.g., `R:2h15m`) -- compute from `usage.resetsAt` relative to current time. If resetsAt is nil, show `R:--`.
- Join visible fields with `config.separator`
- Wrap with `config.prefix` and `config.suffix`
- If `config.useColors` is true, also write a second file `~/.tokemon/statusline-color` with ANSI escape sequences:
  - Green (\\033[32m) for percentage < 50%
  - Yellow (\\033[33m) for 50-79%
  - Red (\\033[31m) for >= 80%
  - Reset (\\033[0m) after the content
- Write plain text (no ANSI) to `~/.tokemon/statusline` always (for scripts that don't want colors)

Use `Data.write(to:options:.atomic)` for atomic file writes to prevent partial reads.

Also write a JSON file `~/.tokemon/status.json` containing the raw values as a simple dictionary:
```json
{"session_pct": 42.0, "weekly_pct": 78.0, "reset_minutes": 135, "reset_time": "2026-02-17T14:30:00Z", "updated": "2026-02-17T12:15:00Z"}
```
This allows advanced users to build custom integrations. Use optional chaining -- omit fields that are nil.

**Constants.swift:**
Add to the Constants enum:
- `static let statuslineDirectory = "~/.tokemon"` -- directory for statusline cache
- `static let statuslineConfigKey = "tokemon.statuslineConfig"` -- UserDefaults key
  </action>
  <verify>
Run `swift build` from the project root. The build should succeed with no errors. Verify the new files exist at the expected paths.
  </verify>
  <done>
StatuslineConfig model persists to/from UserDefaults. StatuslineExporter.export() writes plain text to ~/.tokemon/statusline, colored text to ~/.tokemon/statusline-color, and JSON to ~/.tokemon/status.json. Constants updated with new keys. Project compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create shell helper script for bash/zsh prompt integration</name>
  <files>
    Tokemon/Resources/tokemon-statusline.sh
  </files>
  <action>
Create a POSIX-compatible shell script `tokemon-statusline.sh` that provides a `tokemon_statusline` function for use in PS1/PROMPT.

The script should:

1. Define a `tokemon_statusline()` function that:
   - Checks if `~/.tokemon/statusline` exists. If not, prints nothing (graceful degradation when Tokemon isn't running).
   - Checks file age -- if the file is older than 5 minutes (300 seconds), print nothing (stale data indicator). Use `stat` for age check (handle both GNU and BSD stat syntax with a fallback).
   - If `$TOKEMON_COLOR` is set to "0" or "false", read from `~/.tokemon/statusline` (plain). Otherwise read from `~/.tokemon/statusline-color` if it exists, falling back to plain.
   - Print the file contents (no trailing newline -- use `printf "%s"`).

2. Define a `tokemon_json()` function that:
   - Reads `~/.tokemon/status.json` and outputs it (for users who want to parse JSON with jq or similar).

3. Include a comment header with:
   - Description of what the script does
   - Usage instructions for bash: `PS1='$(tokemon_statusline) \$ '`
   - Usage instructions for zsh: `PROMPT='$(tokemon_statusline) %# '` (with `setopt PROMPT_SUBST` note)
   - How to disable colors: `export TOKEMON_COLOR=0`
   - Where the script is installed by the app

4. The script must NOT use bashisms -- keep it POSIX sh compatible so it works in both bash and zsh without issues. Exception: the instructions can mention bash/zsh-specific prompt syntax.

5. Add `tokemon-statusline.sh` to the Package.swift resources:
   - Add `.copy("Resources/tokemon-statusline.sh")` to the resources array in the executable target

Do NOT modify Package.swift resources yet -- that will happen in Plan 02 when we wire everything together. For now, just create the script file.
  </action>
  <verify>
Run `sh -n Tokemon/Resources/tokemon-statusline.sh` to verify the script has no syntax errors. Run `shellcheck Tokemon/Resources/tokemon-statusline.sh 2>/dev/null || echo "shellcheck not installed, syntax check passed"` for additional validation.
  </verify>
  <done>
Shell helper script exists at Tokemon/Resources/tokemon-statusline.sh. It defines tokemon_statusline() and tokemon_json() functions. Script passes sh -n syntax validation. Script handles missing files gracefully and supports color toggle via TOKEMON_COLOR env var.
  </done>
</task>

</tasks>

<verification>
1. `swift build` succeeds with all new files
2. Shell script passes syntax validation
3. StatuslineConfig can be instantiated with defaults and serialized to/from JSON
4. StatuslineExporter creates ~/.tokemon/ directory structure
</verification>

<success_criteria>
- StatuslineExporter service can write usage data to ~/.tokemon/statusline in plain text format
- Shell helper script provides tokemon_statusline() function for prompt integration
- StatuslineConfig model supports all customization fields (session %, weekly %, reset timer, separator, colors, prefix/suffix)
- All files compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-terminal-statusline/13-01-SUMMARY.md`
</output>
