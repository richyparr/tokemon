---
phase: 17-budget-forecasting-pro
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Tokemon/Models/BudgetConfig.swift
  - Tokemon/Services/BudgetManager.swift
  - Tokemon/Services/ForecastingEngine.swift
  - Tokemon/Services/AdminAPIClient.swift
  - Tokemon/Services/FeatureAccessManager.swift
  - Tokemon/Utilities/Constants.swift
autonomous: true

must_haves:
  truths:
    - "BudgetConfig stores monthly dollar limit and persists via UserDefaults"
    - "BudgetManager tracks current spend from Admin API cost data and fires budget threshold alerts"
    - "ForecastingEngine predicts time-to-budget-limit and calculates pace indicator"
    - "AdminAPIClient can fetch cost data grouped by workspace for project attribution"
  artifacts:
    - path: "Tokemon/Models/BudgetConfig.swift"
      provides: "Budget configuration model with monthly limit, enabled state, threshold levels"
      contains: "struct BudgetConfig"
    - path: "Tokemon/Services/BudgetManager.swift"
      provides: "Budget tracking service with cost fetching, threshold alerts, and spend tracking"
      contains: "class BudgetManager"
    - path: "Tokemon/Services/ForecastingEngine.swift"
      provides: "Cost forecasting with pace indicator and time-to-limit prediction"
      contains: "struct ForecastingEngine"
    - path: "Tokemon/Services/AdminAPIClient.swift"
      provides: "fetchCostByWorkspace method for project-level cost attribution"
      contains: "fetchCostByWorkspace"
    - path: "Tokemon/Services/FeatureAccessManager.swift"
      provides: "ProFeature.budgetTracking and .usageForecasting cases"
      contains: "budgetTracking"
    - path: "Tokemon/Utilities/Constants.swift"
      provides: "budgetConfigKey for UserDefaults storage"
      contains: "budgetConfigKey"
  key_links:
    - from: "Tokemon/Services/BudgetManager.swift"
      to: "Tokemon/Services/AdminAPIClient.swift"
      via: "fetchAllCostData and fetchCostByWorkspace calls"
      pattern: "AdminAPIClient\\.shared\\.fetch"
    - from: "Tokemon/Services/BudgetManager.swift"
      to: "Tokemon/Models/BudgetConfig.swift"
      via: "config property for budget settings"
      pattern: "BudgetConfig"
    - from: "Tokemon/Services/ForecastingEngine.swift"
      to: "Tokemon/Services/BudgetManager.swift"
      via: "uses current spend and daily cost rate for predictions"
      pattern: "currentSpend|dailyRate"
---

<objective>
Budget & Forecasting data layer: models, services, and API extensions for dollar-based budget tracking and usage prediction.

Purpose: Establish the data foundation that the UI layer (Plan 02) will consume -- budget configuration, cost tracking with threshold alerts, cost forecasting, and project-level cost attribution via the Admin API.

Output: BudgetConfig model, BudgetManager service, ForecastingEngine, AdminAPIClient workspace cost extension, ProFeature cases.
</objective>

<execution_context>
@/Users/richardparr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardparr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@Tokemon/Models/AdminUsageResponse.swift
@Tokemon/Services/AdminAPIClient.swift
@Tokemon/Services/AlertManager.swift
@Tokemon/Services/BurnRateCalculator.swift
@Tokemon/Services/FeatureAccessManager.swift
@Tokemon/Utilities/Constants.swift
@Tokemon/Models/WebhookConfig.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: BudgetConfig model, Constants key, and ProFeature cases</name>
  <files>
    Tokemon/Models/BudgetConfig.swift
    Tokemon/Utilities/Constants.swift
    Tokemon/Services/FeatureAccessManager.swift
  </files>
  <action>
    Create `Tokemon/Models/BudgetConfig.swift` with a `BudgetConfig` struct:
    - Properties: `isEnabled: Bool` (default false), `monthlyLimitDollars: Double` (default 100.0), `alertThresholds: [Int]` (default [50, 75, 90] -- the three budget alert levels from BUDG-03)
    - Conformance: `Codable`, `Sendable`
    - Static methods: `load() -> BudgetConfig` (reads from UserDefaults using Constants.budgetConfigKey, returns default if not found), `save(_ config: BudgetConfig)` (encodes to JSON and writes to UserDefaults)
    - Follow the same pattern as `WebhookConfig.swift` for UserDefaults persistence (JSONEncoder/JSONDecoder)

    Add to `Constants.swift`:
    - `static let budgetConfigKey = "tokemon.budgetConfig"` in a new `// MARK: - Budget & Forecasting` section

    Add to `FeatureAccessManager.swift` ProFeature enum:
    - `.budgetTracking = "Budget tracking"` case with icon `"dollarsign.gauge.chart.lefthalf.righthalf"` (under a `// Phase 17: Budget & Forecasting PRO` comment)
    - `.usageForecasting = "Usage forecasting"` case with icon `"chart.line.uptrend.xyaxis"`
  </action>
  <verify>Run `swift build` from project root -- must compile with no errors.</verify>
  <done>BudgetConfig.swift exists with save/load, Constants has budgetConfigKey, ProFeature has budgetTracking and usageForecasting cases.</done>
</task>

<task type="auto">
  <name>Task 2: BudgetManager service, ForecastingEngine, and AdminAPIClient cost-by-workspace extension</name>
  <files>
    Tokemon/Services/BudgetManager.swift
    Tokemon/Services/ForecastingEngine.swift
    Tokemon/Services/AdminAPIClient.swift
  </files>
  <action>
    **AdminAPIClient extension** -- add to existing `AdminAPIClient.swift`:
    - Add `workspaceId: String?` property to `AdminCostResponse.CostResult` (the API returns this when `group_by=workspace` is used). Add it as an optional decoded field with CodingKey `workspace_id`.
    - Add `fetchCostByWorkspace(startingAt:endingAt:bucketWidth:)` method that mirrors `fetchUsageByMember` pattern: same cost_report endpoint but adds `group_by=workspace` query parameter. Handles pagination. Returns `AdminCostResponse` with `workspaceId` populated in each result.

    **BudgetManager** -- create `Tokemon/Services/BudgetManager.swift`:
    - `@Observable @MainActor final class BudgetManager`
    - Properties:
      - `config: BudgetConfig` (loaded from UserDefaults on init)
      - `currentMonthSpend: Double` (total $ spent this calendar month, fetched from Admin API)
      - `dailyCostData: [(date: Date, cost: Double)]` (daily cost breakdown for the current month, for forecasting)
      - `projectCosts: [(workspaceId: String, cost: Double)]` (cost by workspace for BUDG-04)
      - `isLoading: Bool`
      - `errorMessage: String?`
      - `@ObservationIgnored private var notifiedThresholds: Set<Int>` (tracks which budget thresholds have been notified this month, like AlertManager's once-per-level pattern)
      - `@ObservationIgnored private var lastFetchMonth: Int` (calendar month of last fetch, to detect month rollover and reset notifiedThresholds)
    - `saveConfig()` method: calls `BudgetConfig.save(config)`, posts NotificationCenter notification `BudgetManager.configChangedNotification` (static let)
    - `fetchCurrentMonthCost()` async method:
      - Calculate start of current calendar month and now as date range
      - Call `AdminAPIClient.shared.fetchAllCostData(startingAt:endingAt:bucketWidth:"1d")` to get total month spend
      - Call `AdminAPIClient.shared.fetchCostByWorkspace(startingAt:endingAt:)` to get per-workspace costs
      - Set `currentMonthSpend` from totalCost, set `dailyCostData` from individual bucket costs, set `projectCosts` from workspace-grouped results
      - If calendar month changed since last fetch, reset `notifiedThresholds`
      - Set `lastFetchMonth` to current month
    - `checkBudgetThresholds()` method:
      - Guard `config.isEnabled` and `config.monthlyLimitDollars > 0`
      - Calculate `spendPercentage = (currentMonthSpend / config.monthlyLimitDollars) * 100`
      - For each threshold in config.alertThresholds (50, 75, 90): if spendPercentage >= threshold and threshold not in notifiedThresholds, add to notifiedThresholds and call `sendBudgetNotification(threshold:spendPercentage:)`
    - `sendBudgetNotification(threshold:spendPercentage:)` private method:
      - Guard `Bundle.main.bundleIdentifier != nil`
      - Create UNMutableNotificationContent with title "Budget Alert", subtitle "Tokemon", body "You've spent {spendPercentage}% of your ${monthlyLimit} monthly budget."
      - Use `.timeSensitive` interruption level (matching AlertManager pattern)
      - Fire via UNUserNotificationCenter
    - `var budgetUtilization: Double` computed property: returns `(currentMonthSpend / config.monthlyLimitDollars) * 100` (clamped 0-100+), or 0 if limit is 0

    **ForecastingEngine** -- create `Tokemon/Services/ForecastingEngine.swift`:
    - `struct ForecastingEngine` (stateless, static methods like BurnRateCalculator)
    - `enum PaceIndicator: String, Sendable` with cases `.onPace = "On Pace"`, `.ahead = "Ahead"`, `.behind = "Behind"`, `.unknown = "â€”"`
      - Each case has a computed `color` property: `.onPace` -> green, `.ahead` -> red (spending faster), `.behind` -> blue (spending slower)
      - Each case has a computed `icon` property: `.onPace` -> "equal.circle.fill", `.ahead` -> "arrow.up.circle.fill", `.behind` -> "arrow.down.circle.fill", `.unknown` -> "questionmark.circle"
    - `static func calculateDailySpendRate(from dailyCosts: [(date: Date, cost: Double)]) -> Double?`:
      - Need at least 2 data points
      - Calculate average daily spend from the provided daily cost data
      - Return average $ per day, or nil if insufficient data
    - `static func predictedMonthlySpend(currentSpend: Double, dailyRate: Double, dayOfMonth: Int, daysInMonth: Int) -> Double`:
      - Project total month spend: `currentSpend + dailyRate * Double(daysInMonth - dayOfMonth)`
    - `static func paceIndicator(currentSpend: Double, monthlyBudget: Double, dayOfMonth: Int, daysInMonth: Int) -> PaceIndicator`:
      - Calculate expected spend at this point: `(monthlyBudget / Double(daysInMonth)) * Double(dayOfMonth)`
      - If currentSpend within 10% of expected: `.onPace`
      - If currentSpend > expected * 1.10: `.ahead` (spending faster than budget allows)
      - If currentSpend < expected * 0.90: `.behind` (under budget)
      - If insufficient data: `.unknown`
    - `static func timeToLimit(currentSpend: Double, monthlyBudget: Double, dailyRate: Double) -> TimeInterval?`:
      - If dailyRate <= 0 or currentSpend >= monthlyBudget: return nil
      - remainingBudget = monthlyBudget - currentSpend
      - daysRemaining = remainingBudget / dailyRate
      - Return daysRemaining * 86400 (seconds)
    - `static func formatTimeToLimit(_ seconds: TimeInterval) -> String`:
      - If > 30 days: ">30d"
      - If > 1 day: "{N}d {H}h"
      - If > 1 hour: "{H}h {M}m"
      - If > 0: "{M}m"
      - Else: "--"
  </action>
  <verify>Run `swift build` from project root -- must compile with no errors.</verify>
  <done>BudgetManager.swift exists with cost fetching, threshold alerts, and spend tracking. ForecastingEngine.swift exists with pace indicator, daily rate calculation, and time-to-limit prediction. AdminAPIClient has fetchCostByWorkspace method. All compile cleanly.</done>
</task>

</tasks>

<verification>
- `swift build` succeeds with no errors
- `BudgetConfig.load()` and `BudgetConfig.save()` compile
- `BudgetManager()` can be instantiated
- `ForecastingEngine.paceIndicator(...)` returns a PaceIndicator enum value
- `AdminAPIClient.shared.fetchCostByWorkspace(startingAt:endingAt:)` compiles
- `ProFeature.budgetTracking` and `ProFeature.usageForecasting` exist
- `Constants.budgetConfigKey` exists
</verification>

<success_criteria>
All 6 files created/modified, `swift build` passes, data layer complete for Plan 02 consumption.
</success_criteria>

<output>
After completion, create `.planning/phases/17-budget-forecasting-pro/17-01-SUMMARY.md`
</output>
