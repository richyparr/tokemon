---
phase: 10-enhanced-export
plan: 03
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - Tokemon/Services/ExportManager.swift
  - Tokemon/Views/Analytics/PDFReportView.swift
autonomous: true

must_haves:
  truths:
    - "CSV export includes 7 columns: Date, Total, Input, Output, Cache Read, Cache Create, Cost"
    - "PDF report uses adaptive breakdown: daily for <30d, weekly for 30-90d, monthly for >90d"
    - "PDF report includes summary section at top with totals and key metrics"
    - "PDF supports multiple pages for large date ranges without shrinking to unreadable size"
    - "Export filenames follow tokemon-{type}-{period}.{ext} format"
    - "Full 4-column cache token breakdown: Input, Cache Creation, Cache Read, Output"
  artifacts:
    - path: "Tokemon/Services/ExportManager.swift"
      provides: "Enhanced CSV generation with 7 columns, config-driven filenames, multi-page PDF generation"
      contains: "Cache Create"
    - path: "Tokemon/Views/Analytics/PDFReportView.swift"
      provides: "Adaptive granularity PDF with summary section, page-chunked data tables"
      contains: "ReportGranularity"
  key_links:
    - from: "Tokemon/Services/ExportManager.swift"
      to: "Tokemon/Models/ExportConfig.swift"
      via: "ExportConfig provides date range and granularity for export generation"
      pattern: "ExportConfig|ReportGranularity"
    - from: "Tokemon/Views/Analytics/PDFReportView.swift"
      to: "Tokemon/Models/AdminUsageResponse.swift"
      via: "PDFReportView consumes usage buckets and renders adaptive tables"
      pattern: "AdminUsageResponse|UsageBucket"
    - from: "Tokemon/Services/ExportManager.swift"
      to: "Tokemon/Views/Analytics/PDFReportView.swift"
      via: "generateMultiPagePDF renders multiple PDFReportPage views"
      pattern: "generateMultiPagePDF|PDFReportPage"
---

<objective>
Enhance CSV export with 7-column layout including cache creation and cost, rebuild PDF export with adaptive date granularity and multi-page support, and add config-driven filename generation.

Purpose: This transforms the export output from basic 5-column CSV and single-page PDF with hardcoded date ranges into rich, date-range-aware exports with full token breakdown, cost data, and readable multi-page PDFs for any time period.

Output: Enhanced ExportManager.swift with new CSV format and multi-page PDF capability, rebuilt PDFReportView.swift with adaptive granularity and summary section.
</objective>

<execution_context>
@/Users/richardparr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardparr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-enhanced-export/10-RESEARCH.md
@.planning/phases/10-enhanced-export/10-01-SUMMARY.md
@Tokemon/Services/ExportManager.swift
@Tokemon/Views/Analytics/PDFReportView.swift
@Tokemon/Models/AdminUsageResponse.swift
@Tokemon/Models/ExportConfig.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance CSV generation with 7-column layout and cost data</name>
  <files>Tokemon/Services/ExportManager.swift</files>
  <action>
Update `Tokemon/Services/ExportManager.swift`:

1. **Enhance `generateAdminCSV`** to accept `ExportConfig` and `AdminCostResponse?` parameters alongside `AdminUsageResponse`:
```swift
static func generateAdminCSV(
    from usage: AdminUsageResponse,
    cost: AdminCostResponse?,
    config: ExportConfig
) -> String
```

New CSV column order per locked decision: **Date, Total Tokens, Input Tokens, Output Tokens, Cache Read Tokens, Cache Create Tokens, Cost**

For each usage bucket:
- Date: format the `startingAt` ISO8601 string to `yyyy-MM-dd`
- Total: `bucket.totalTokens`
- Input: `bucket.inputTokens` (this is uncached input + cache creation per existing logic)
- Output: `bucket.outputTokens`
- Cache Read: `bucket.cacheReadTokens`
- Cache Create: `bucket.cacheCreationTokens` (new field from Plan 01)
- Cost: Look up matching cost bucket by date. If found, format as decimal string (e.g., "1.23"). If no cost data, leave empty string.

Match cost buckets to usage buckets by comparing `startingAt` strings (they should align for daily buckets). Handle the case where cost data has fewer buckets than usage data gracefully.

The "Input" column in the CSV should represent pure uncached input tokens only (NOT uncached + cache creation, which is the current behavior of `bucket.inputTokens`). The 4 separate columns should be: Input (uncached only), Output, Cache Read, Cache Create. This means Input + Cache Create + Cache Read + Output should NOT equal Total (Total = uncached input + cache creation + cache read + output = Input column + Cache Create + Cache Read + Output). Actually -- looking at the locked decision more carefully: "Full cache token breakdown: Input, Cache Creation, Cache Read, Output (4 separate columns)". The user wants Input to be the "input" column. Since the existing `bucket.inputTokens` adds uncached + cacheCreation, we need a separate computed property. Add `uncachedInputTokens` to `UsageBucket` that only sums `results.reduce(0) { $0 + $1.uncachedInputTokens }`. Use this for the Input CSV column. Then `cacheCreationTokens` is the Cache Create column. This way the 4 columns cleanly separate all token types.

2. **Update `generateCSV` (local data)** to also accept an `ExportConfig` for consistent filename support, but keep the same local data columns (Timestamp, Utilization %, 7-Day Utilization %, Source) since local data doesn't have token breakdown.

3. **Add `generateMultiPagePDF` static method:**
```swift
static func generateMultiPagePDF(
    pages: [some View],
    filename: String
) -> URL?
```
This method:
- Creates a `CGContext` at a temp file path with US Letter media box (612 x 792 points)
- For each page view, creates an `ImageRenderer` at scale 2.0
- Calls `context.beginPDFPage(nil)` for each
- Applies 36pt margins and scales content to fit within available area (same logic as existing `generatePDF`)
- Calls `context.endPDFPage()` after each page
- Calls `context.closePDF()` after all pages
- Returns the temp file URL

Note: Since `generateMultiPagePDF` needs to handle generic View arrays, implement it to accept an array of `AnyView` or use a closure-based approach where the caller provides page views one at a time. Simplest approach: accept `[AnyView]`.

4. **Update `exportPDF` method** to have an overload that accepts a filename parameter to use config-driven filenames:
```swift
static func exportPDF(
    reportView: some View,
    suggestedFilename: String = "Tokemon-Report.pdf"
) async -> Bool
```
Add a new overload:
```swift
static func exportMultiPagePDF(
    pages: [AnyView],
    suggestedFilename: String
) async -> Bool
```
This calls `generateMultiPagePDF`, then shows `NSSavePanel` with the suggested filename, copies to destination, reveals in Finder. Same pattern as existing `exportPDF`.

5. **Update `exportAdminCSV`** to accept the enhanced parameters and use config-driven filename.

Keep all existing methods working (they may still be called from other places). Add new overloads rather than breaking signatures, unless the old signatures are only called from AnalyticsDashboardView (which Plan 02 is updating simultaneously -- in that case, coordinate by keeping both old and new methods, Plan 02 will call the new ones).
  </action>
  <verify>Build with `swift build`. Verify: generateAdminCSV has 7-column header. generateMultiPagePDF method exists. exportMultiPagePDF method exists. No compilation errors.</verify>
  <done>CSV generation produces 7 columns (Date, Total, Input, Output, Cache Read, Cache Create, Cost). Multi-page PDF generation method exists. Config-driven filenames supported. UsageBucket has uncachedInputTokens for clean column separation. Builds cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Rebuild PDFReportView with adaptive granularity and multi-page support</name>
  <files>Tokemon/Views/Analytics/PDFReportView.swift</files>
  <action>
Rebuild `Tokemon/Views/Analytics/PDFReportView.swift` to support adaptive date granularity and multi-page output:

**New approach:** Instead of one monolithic view, create page-sized views that the multi-page PDF renderer (from Task 1) will render individually.

1. **Create `PDFReportPage` view** (can be in the same file) that represents a single PDF page:
```swift
struct PDFReportPage: View {
    let pageNumber: Int
    let totalPages: Int
    let content: AnyView

    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            content
            Spacer(minLength: 0)
            // Footer on every page
            HStack {
                Text("Generated by Tokemon - tokemon.ai")
                    .font(.system(size: 8))
                    .foregroundStyle(.gray)
                Spacer()
                Text("Page \(pageNumber) of \(totalPages)")
                    .font(.system(size: 8))
                    .foregroundStyle(.gray)
            }
        }
        .padding(24)
        .frame(width: 540, height: 720) // US Letter minus margins
        .background(.white)
    }
}
```

2. **Create `PDFReportBuilder` struct** (in the same file) with a static method that produces an array of `AnyView` pages:
```swift
static func buildPages(
    accountName: String,
    generatedDate: Date,
    config: ExportConfig,
    adminUsageData: AdminUsageResponse?,
    adminCostData: AdminCostResponse?,
    localWeeklySummaries: [UsageSummary],
    localMonthlySummaries: [UsageSummary],
    localProjectBreakdown: [ProjectUsage]
) -> [AnyView]
```

This method:

a. **Page 1: Summary page.** Per locked decision: "PDF includes summary section at top (totals + key metrics first)."
   - Title: "Tokemon Usage Report"
   - Subtitle: account name + "(Admin API)" or "(Local Data)" + date
   - Date range: formatted start - end date
   - Summary metrics table:
     - Total Tokens, Input Tokens, Output Tokens, Cache Read, Cache Create
     - Total Cost (if admin data with cost)
   - Start of the detail table (as many rows as fit after summary)

b. **Detail table with adaptive granularity:**
   - Use `config.granularity` to determine aggregation:
     - `.daily`: Show one row per day from usage data. For admin: each UsageBucket is already daily. For local: group by day.
     - `.weekly`: Aggregate admin buckets into weeks using Calendar. For local: use existing weekly summaries.
     - `.monthly`: Aggregate admin buckets into months. For local: use existing monthly summaries.
   - Admin data columns (table-only, per locked decision: "PDF uses tables only (no charts)"):
     - Date | Total | Input | Output | Cache Read | Cache Create | Cost
   - Local data columns:
     - Date | Avg Utilization | Peak Utilization | Data Points
   - Column headers repeat on each page.

c. **Page chunking:** Estimate ~38 data rows per page (per research: 720pt usable / ~18pt per row, minus headers). First page has fewer rows due to summary section (~20 data rows). Subsequent pages: ~38 rows each.

d. Each page wrapped in `PDFReportPage` with page number and total.

3. **Keep the existing `PDFReportView`** for backward compatibility but mark it with a deprecation comment. The new flow is: `PDFReportBuilder.buildPages(...)` -> `ExportManager.generateMultiPagePDF(pages:filename:)`.

4. **Formatting helpers** (keep or adapt existing ones):
   - `formatTokens(_:)` — compact token display (1.2M, 3.4K, etc.)
   - `formatBucketDate(_:)` — ISO8601 to readable date
   - Add `formatCost(_:)` — dollar formatting with 2 decimal places
   - Add aggregation helpers for weekly/monthly grouping of admin data buckets

Use system font at sizes consistent with research recommendations: 10pt for table data, 12pt for headers, 16pt for title. All text `.foregroundStyle(.black)` for PDF rendering (no @Environment colors).
  </action>
  <verify>Build with `swift build`. Verify: PDFReportBuilder.buildPages exists and returns [AnyView]. PDFReportPage has footer with page numbers. Adaptive granularity uses ReportGranularity. Admin table has 7 columns. Page chunking logic splits data at ~38 rows per page.</verify>
  <done>PDFReportView.swift contains PDFReportPage (per-page wrapper with footer), PDFReportBuilder (static page builder with adaptive granularity), and aggregation helpers. Summary section on page 1. Table-only layout. Daily/weekly/monthly breakdown based on config. Multi-page chunking at ~38 rows. Builds cleanly.</done>
</task>

</tasks>

<verification>
- `swift build` succeeds with no errors
- CSV header is "Date,Total Tokens,Input Tokens,Output Tokens,Cache Read Tokens,Cache Create Tokens,Cost"
- PDFReportBuilder.buildPages returns multiple pages for large datasets
- PDFReportPage includes page number footer on every page
- Adaptive granularity: daily for <30d, weekly for 30-90d, monthly for >90d
- Summary section appears on first page of PDF
- ExportManager has generateMultiPagePDF and exportMultiPagePDF methods
- Existing single-page PDF method still works for backward compatibility
</verification>

<success_criteria>
- CSV exports have all 7 columns with cost data when available
- PDF reports adapt their detail level based on date range length
- Multi-page PDF renders correctly for 90+ day exports
- Summary section at top of PDF shows totals and key metrics
- All 4 cache token types shown separately (Input, Cache Creation, Cache Read, Output)
- Filenames follow locked format: tokemon-{type}-{period}.{ext}
</success_criteria>

<output>
After completion, create `.planning/phases/10-enhanced-export/10-03-SUMMARY.md`
</output>
